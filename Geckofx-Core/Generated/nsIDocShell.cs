// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIDocShell.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// The nsIDocShell interface.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("4277354d-5069-4278-935a-5d596ce9bfbf")]
	public interface nsIDocShell : nsIDocShellTreeItem
	{
		
		/// <summary>
        ///The current number of DocShells which are immediate children of the
        ///	this object.
        ///	 </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new int GetChildCountAttribute();
		
		/// <summary>
        ///Add a new child DocShellTreeItem.  Adds to the end of the list.
        ///	Note that this does NOT take a reference to the child.  The child stays
        ///	alive only as long as it's referenced from outside the docshell tree.
        ///	@throws NS_ERROR_ILLEGAL_VALUE if child corresponds to the same
        ///	        object as this treenode or an ancestor of this treenode
        ///	@throws NS_ERROR_UNEXPECTED if this node is a leaf in the tree.
        ///	 </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddChild([MarshalAs(UnmanagedType.Interface)] nsIDocShellTreeItem child);
		
		/// <summary>
        ///Removes a child DocShellTreeItem.
        ///	@throws NS_ERROR_UNEXPECTED if this node is a leaf in the tree.
        ///	 </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveChild([MarshalAs(UnmanagedType.Interface)] nsIDocShellTreeItem child);
		
		/// <summary>
        /// Return the child at the index requested.  This is 0-based.
        ///
        /// @throws NS_ERROR_UNEXPECTED if the index is out of range
        ///	 </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDocShellTreeItem GetChildAt(int index);
		
		/// <summary>
        ///Return the child DocShellTreeItem with the specified name.
        ///	aName - This is the name of the item that is trying to be found.
        ///	aRecurse - Is used to tell the function to recurse through children.
        ///		Note, recursion will only happen through items of the same type.
        ///	aSameType - If this is set only children of the same type will be returned.
        ///	aRequestor - This is the docshellTreeItem that is requesting the find.  This
        ///		parameter is used when recursion is being used to avoid searching the same
        ///		tree again when a child has asked a parent to search for children.
        ///	aOriginalRequestor - The original treeitem that made the request, if any.
        ///    	This is used to ensure that we don't run into cross-site issues.
        ///	Note the search is depth first when recursing.
        ///	 </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDocShellTreeItem FindChildWithName([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string aName, [MarshalAs(UnmanagedType.U1)] bool aRecurse, [MarshalAs(UnmanagedType.U1)] bool aSameType, [MarshalAs(UnmanagedType.Interface)] nsIDocShellTreeItem aRequestor, [MarshalAs(UnmanagedType.Interface)] nsIDocShellTreeItem aOriginalRequestor);
		
		/// <summary>
        ///name of the DocShellTreeItem
        ///	 </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aName);
		
		/// <summary>
        ///name of the DocShellTreeItem
        ///	 </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aName);
		
		/// <summary>
        /// Compares the provided name against the item's name and
        /// returns the appropriate result.
        ///
        /// @return <CODE>PR_TRUE</CODE> if names match;
        /// <CODE>PR_FALSE</CODE> otherwise.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool NameEquals([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string name);
		
		/// <summary>
        ///The type this item is.
        ///	 </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new int GetItemTypeAttribute();
		
		/// <summary>
        ///The type this item is.
        ///	 </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetItemTypeAttribute(int aItemType);
		
		/// <summary>
        ///Parent DocShell.
        ///	 </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDocShellTreeItem GetParentAttribute();
		
		/// <summary>
        ///This getter returns the same thing parent does however if the parent
        ///	is of a different itemType, or if the parent is an <iframe mozbrowser>
        ///	or <iframe mozapp>, it will instead return nullptr.  This call is a
        ///	convience function for those wishing to not cross the boundaries at
        ///	which item types change.
        ///	 </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDocShellTreeItem GetSameTypeParentAttribute();
		
		/// <summary>
        ///Returns the root DocShellTreeItem.  This is a convience equivalent to
        ///	getting the parent and its parent until there isn't a parent.
        ///	 </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDocShellTreeItem GetRootTreeItemAttribute();
		
		/// <summary>
        ///Returns the root DocShellTreeItem of the same type.  This is a convience
        ///	equivalent to getting the parent of the same type and its parent until
        ///	there isn't a parent.
        ///	 </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDocShellTreeItem GetSameTypeRootTreeItemAttribute();
		
		/// <summary>
        ///Returns the docShellTreeItem with the specified name.  Search order is as
        ///	follows...
        ///	1.)  Check name of self, if it matches return it.
        ///	2.)  For each immediate child.
        ///		a.) Check name of child and if it matches return it.
        ///		b.)  Ask the child to perform the check
        ///			i.) Do not ask a child if it is the aRequestor
        ///			ii.) Do not ask a child if it is of a different item type.
        ///	3.)  If there is a parent of the same item type ask parent to perform the check
        ///		a.) Do not ask parent if it is the aRequestor
        ///	4.)  If there is a tree owner ask the tree owner to perform the check
        ///		a.)  Do not ask the tree owner if it is the aRequestor
        ///		b.)  This should only be done if there is no parent of the same type.
        ///	Return the child DocShellTreeItem with the specified name.
        ///	name - This is the name of the item that is trying to be found.
        ///	aRequestor - This is the object that is requesting the find.  This
        ///		parameter is used to identify when the child is asking its parent to find
        ///		a child with the specific name.  The parent uses this parameter to ensure
        ///		a resursive state does not occur by not again asking the requestor to find
        ///		a shell by the specified name.  Inversely the child uses it to ensure it
        ///		does not ask its parent to do the search if its parent is the one that
        ///		asked it to search.  Children also use this to test against the treeOwner;
        ///	aOriginalRequestor - The original treeitem that made the request, if any.
        ///		This is used to ensure that we don't run into cross-site issues.
        ///	 </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDocShellTreeItem FindItemWithName([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string name, [MarshalAs(UnmanagedType.Interface)] nsISupports aRequestor, [MarshalAs(UnmanagedType.Interface)] nsIDocShellTreeItem aOriginalRequestor);
		
		/// <summary>
        ///The owner of the DocShell Tree.  This interface will be called upon when
        ///	the docshell has things it needs to tell to the owner of the docshell.
        ///	Note that docShell tree ownership does not cross tree types.  Meaning
        ///	setting ownership on a chrome tree does not set ownership on the content
        ///	sub-trees.  A given tree's boundaries are identified by the type changes.
        ///	Trees of different types may be connected, but should not be traversed
        ///	for things such as ownership.
        ///	
        ///	Note implementers of this interface should NOT effect the lifetime of the
        ///	parent DocShell by holding this reference as it creates a cycle.  Owners
        ///	when releasing this interface should set the treeOwner to nullptr.
        ///	Implementers of this interface are guaranteed that when treeOwner is
        ///	set that the poitner is valid without having to addref.
        ///	
        ///	Further note however when others try to get the interface it should be
        ///	addref'd before handing it to them.
        ///	 </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDocShellTreeOwner GetTreeOwnerAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetTreeOwner([MarshalAs(UnmanagedType.Interface)] nsIDocShellTreeOwner treeOwner);
		
		/// <summary>
        /// Loads a given URI.  This will give priority to loading the requested URI
        /// in the object implementing	this interface.  If it can't be loaded here
        /// however, the URL dispatcher will go through its normal process of content
        /// loading.
        ///
        /// @param uri        - The URI to load.
        /// @param loadInfo   - This is the extended load info for this load.  This
        /// most often will be null, but if you need to do
        /// additional setup for this load you can get a loadInfo
        /// object by calling createLoadInfo.  Once you have this
        /// object you can set the needed properties on it and
        /// then pass it to loadURI.
        /// @param aLoadFlags - Flags to modify load behaviour. Flags are defined in
        /// nsIWebNavigation.  Note that using flags outside
        /// LOAD_FLAGS_MASK is only allowed if passing in a
        /// non-null loadInfo.  And even some of those might not
        /// be allowed.  Use at your own risk.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LoadURI([MarshalAs(UnmanagedType.Interface)] nsIURI uri, [MarshalAs(UnmanagedType.Interface)] nsIDocShellLoadInfo loadInfo, uint aLoadFlags, [MarshalAs(UnmanagedType.U1)] bool firstParty);
		
		/// <summary>
        /// Loads a given stream. This will give priority to loading the requested
        /// stream in the object implementing this interface. If it can't be loaded
        /// here however, the URL dispatched will go through its normal process of
        /// content loading.
        ///
        /// @param aStream         - The input stream that provides access to the data
        /// to be loaded.  This must be a blocking, threadsafe
        /// stream implementation.
        /// @param aURI            - The URI representing the stream, or null.
        /// @param aContentType    - The type (MIME) of data being loaded (empty if unknown).
        /// @param aContentCharset - The charset of the data being loaded (empty if unknown).
        /// @param aLoadInfo       - This is the extended load info for this load.  This
        /// most often will be null, but if you need to do
        /// additional setup for this load you can get a
        /// loadInfo object by calling createLoadInfo.  Once
        /// you have this object you can set the needed
        /// properties on it and then pass it to loadStream.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LoadStream([MarshalAs(UnmanagedType.Interface)] nsIInputStream aStream, [MarshalAs(UnmanagedType.Interface)] nsIURI aURI, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aContentType, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aContentCharset, [MarshalAs(UnmanagedType.Interface)] nsIDocShellLoadInfo aLoadInfo);
		
		/// <summary>
        /// Loads the given URI.  This method is identical to loadURI(...) except
        /// that its parameter list is broken out instead of being packaged inside
        /// of an nsIDocShellLoadInfo object...
        ///
        /// @param aURI            - The URI to load.
        /// @param aReferrer       - Referring URI
        /// @param aOwner          - Owner (security principal)
        /// @param aInheritOwner   - Flag indicating whether the owner of the current
        /// document should be inherited if aOwner is null.
        /// @param aStopActiveDoc  - Flag indicating whether loading the current
        /// document should be stopped.
        /// @param aWindowTarget   - Window target for the load.
        /// @param aTypeHint       - A hint as to the content-type of the resulting
        /// data.  May be null or empty if no hint.
        /// @param aFileName       - Non-null when the link should be downloaded as
        ///                              the given filename.
        /// @param aPostDataStream - Post data stream (if POSTing)
        /// @param aHeadersStream  - Stream containing "extra" request headers...
        /// @param aLoadFlags      - Flags to modify load behaviour. Flags are defined
        /// in nsIWebNavigation.
        /// @param aSHEntry        - Active Session History entry (if loading from SH)
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InternalLoad([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, [MarshalAs(UnmanagedType.Interface)] nsIURI aReferrer, [MarshalAs(UnmanagedType.Interface)] nsISupports aOwner, uint aFlags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Gecko.CustomMarshalers.WStringMarshaler")] string aWindowTarget, [MarshalAs(UnmanagedType.LPStr)] string aTypeHint, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aFileName, [MarshalAs(UnmanagedType.Interface)] nsIInputStream aPostDataStream, [MarshalAs(UnmanagedType.Interface)] nsIInputStream aHeadersStream, uint aLoadFlags, [MarshalAs(UnmanagedType.Interface)] nsISHEntry aSHEntry, [MarshalAs(UnmanagedType.U1)] bool firstParty, [MarshalAs(UnmanagedType.Interface)] ref nsIDocShell aDocShell, [MarshalAs(UnmanagedType.Interface)] ref nsIRequest aRequest);
		
		/// <summary>
        /// Do either a history.pushState() or history.replaceState() operation,
        /// depending on the value of aReplace.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddState([MarshalAs(UnmanagedType.Interface)] nsIVariant aData, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aTitle, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aURL, [MarshalAs(UnmanagedType.U1)] bool aReplace, System.IntPtr jsContext);
		
		/// <summary>
        /// Creates a DocShellLoadInfo object that you can manipulate and then pass
        /// to loadURI.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CreateLoadInfo([MarshalAs(UnmanagedType.Interface)] ref nsIDocShellLoadInfo loadInfo);
		
		/// <summary>
        /// Reset state to a new content model within the current document and the document
        /// viewer.  Called by the document before initiating an out of band document.write().
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PrepareForNewContentModel();
		
		/// <summary>
        /// For editors and suchlike who wish to change the URI associated with the
        /// document. Note if you want to get the current URI, use the read-only
        /// property on nsIWebNavigation.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetCurrentURI([MarshalAs(UnmanagedType.Interface)] nsIURI aURI);
		
		/// <summary>
        /// Notify the associated content viewer and all child docshells that they are
        /// about to be hidden.  If |isUnload| is true, then the document is being
        /// unloaded as well.
        ///
        /// @param isUnload if true, fire the unload event in addition to the pagehide
        /// event.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FirePageHideNotification([MarshalAs(UnmanagedType.U1)] bool isUnload);
		
		/// <summary>
        /// Presentation context for the currently loaded document.  This may be null.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetPresContextAttribute();
		
		/// <summary>
        /// Presentation shell for the currently loaded document.  This may be null.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetPresShell();
		
		/// <summary>
        /// Presentation shell for the oldest document, if this docshell is
        /// currently transitioning between documents.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetEldestPresShellAttribute();
		
		/// <summary>
        /// Content Viewer that is currently loaded for this DocShell.  This may
        /// change as the underlying content changes.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIContentViewer GetContentViewerAttribute();
		
		/// <summary>
        /// This attribute allows chrome to tie in to handle DOM events that may
        /// be of interest to chrome.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMEventTarget GetChromeEventHandlerAttribute();
		
		/// <summary>
        /// This attribute allows chrome to tie in to handle DOM events that may
        /// be of interest to chrome.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetChromeEventHandlerAttribute([MarshalAs(UnmanagedType.Interface)] nsIDOMEventTarget aChromeEventHandler);
		
		/// <summary>
        /// Whether to allow plugin execution
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAllowPluginsAttribute();
		
		/// <summary>
        /// Whether to allow plugin execution
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAllowPluginsAttribute([MarshalAs(UnmanagedType.U1)] bool aAllowPlugins);
		
		/// <summary>
        /// Whether to allow Javascript execution
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAllowJavascriptAttribute();
		
		/// <summary>
        /// Whether to allow Javascript execution
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAllowJavascriptAttribute([MarshalAs(UnmanagedType.U1)] bool aAllowJavascript);
		
		/// <summary>
        /// Attribute stating if refresh based redirects can be allowed
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAllowMetaRedirectsAttribute();
		
		/// <summary>
        /// Attribute stating if refresh based redirects can be allowed
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAllowMetaRedirectsAttribute([MarshalAs(UnmanagedType.U1)] bool aAllowMetaRedirects);
		
		/// <summary>
        /// Attribute stating if it should allow subframes (framesets/iframes) or not
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAllowSubframesAttribute();
		
		/// <summary>
        /// Attribute stating if it should allow subframes (framesets/iframes) or not
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAllowSubframesAttribute([MarshalAs(UnmanagedType.U1)] bool aAllowSubframes);
		
		/// <summary>
        /// Attribute stating whether or not images should be loaded.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAllowImagesAttribute();
		
		/// <summary>
        /// Attribute stating whether or not images should be loaded.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAllowImagesAttribute([MarshalAs(UnmanagedType.U1)] bool aAllowImages);
		
		/// <summary>
        /// Attribute that determines whether DNS prefetch is allowed for this subtree
        /// of the docshell tree.  Defaults to true.  Setting this will make it take
        /// effect starting with the next document loaded in the docshell.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAllowDNSPrefetchAttribute();
		
		/// <summary>
        /// Attribute that determines whether DNS prefetch is allowed for this subtree
        /// of the docshell tree.  Defaults to true.  Setting this will make it take
        /// effect starting with the next document loaded in the docshell.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAllowDNSPrefetchAttribute([MarshalAs(UnmanagedType.U1)] bool aAllowDNSPrefetch);
		
		/// <summary>
        /// Attribute that determines whether window control (move/resize) is allowed.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAllowWindowControlAttribute();
		
		/// <summary>
        /// Attribute that determines whether window control (move/resize) is allowed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAllowWindowControlAttribute([MarshalAs(UnmanagedType.U1)] bool aAllowWindowControl);
		
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISimpleEnumerator GetDocShellEnumerator(int aItemType, int aDirection);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetAppTypeAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAppTypeAttribute(uint aAppType);
		
		/// <summary>
        /// certain dochshells (like the message pane)
        /// should not throw up auth dialogs
        /// because it can act as a password trojan
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAllowAuthAttribute();
		
		/// <summary>
        /// certain dochshells (like the message pane)
        /// should not throw up auth dialogs
        /// because it can act as a password trojan
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAllowAuthAttribute([MarshalAs(UnmanagedType.U1)] bool aAllowAuth);
		
		/// <summary>
        /// Set/Get the document scale factor.  When setting this attribute, a
        /// NS_ERROR_NOT_IMPLEMENTED error may be returned by implementations
        /// not supporting zoom.  Implementations not supporting zoom should return
        /// 1.0 all the time for the Get operation.  1.0 by the way is the default
        /// of zoom.  This means 100% of normal scaling or in other words normal size
        /// no zoom.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		float GetZoomAttribute();
		
		/// <summary>
        /// Set/Get the document scale factor.  When setting this attribute, a
        /// NS_ERROR_NOT_IMPLEMENTED error may be returned by implementations
        /// not supporting zoom.  Implementations not supporting zoom should return
        /// 1.0 all the time for the Get operation.  1.0 by the way is the default
        /// of zoom.  This means 100% of normal scaling or in other words normal size
        /// no zoom.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetZoomAttribute(float aZoom);
		
		/// <summary>
        /// The size, in CSS pixels, of the horizontal margins for the <body> of an
        /// HTML document in this docshel; used to implement the marginwidth attribute
        /// on HTML <frame>/<iframe> elements.  A value smaller than zero indicates
        /// that the attribute was not set.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetMarginWidthAttribute();
		
		/// <summary>
        /// The size, in CSS pixels, of the horizontal margins for the <body> of an
        /// HTML document in this docshel; used to implement the marginwidth attribute
        /// on HTML <frame>/<iframe> elements.  A value smaller than zero indicates
        /// that the attribute was not set.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetMarginWidthAttribute(int aMarginWidth);
		
		/// <summary>
        /// The size, in CSS pixels, of the vertical margins for the <body> of an HTML
        /// document in this docshel; used to implement the marginheight attribute on
        /// HTML <frame>/<iframe> elements.  A value smaller than zero indicates that
        /// the attribute was not set.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetMarginHeightAttribute();
		
		/// <summary>
        /// The size, in CSS pixels, of the vertical margins for the <body> of an HTML
        /// document in this docshel; used to implement the marginheight attribute on
        /// HTML <frame>/<iframe> elements.  A value smaller than zero indicates that
        /// the attribute was not set.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetMarginHeightAttribute(int aMarginHeight);
		
		/// <summary>
        /// Tells the docshell to offer focus to its tree owner.
        /// This is currently only necessary for embedding chrome.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void TabToTreeOwner([MarshalAs(UnmanagedType.U1)] bool forward, [MarshalAs(UnmanagedType.U1)] ref bool tookFocus);
		
		/// <summary>
        /// History.pushState()
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetBusyFlagsAttribute();
		
		/// <summary>
        /// attribute to access the loadtype  for the document
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetLoadTypeAttribute();
		
		/// <summary>
        /// attribute to access the loadtype  for the document
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetLoadTypeAttribute(uint aLoadType);
		
		/// <summary>
        /// returns true if the docshell is being destroyed, false otherwise
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsBeingDestroyed();
		
		/// <summary>
        /// Returns true if the docshell is currently executing the onLoad Handler
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsExecutingOnLoadHandlerAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetLayoutHistoryStateAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetLayoutHistoryStateAttribute(System.IntPtr aLayoutHistoryState);
		
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetShouldSaveLayoutStateAttribute();
		
		/// <summary>
        /// The SecureBrowserUI object for this docshell.  This is set by XUL
        /// <browser> or nsWebBrowser for their root docshell.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISecureBrowserUI GetSecurityUIAttribute();
		
		/// <summary>
        /// The SecureBrowserUI object for this docshell.  This is set by XUL
        /// <browser> or nsWebBrowser for their root docshell.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetSecurityUIAttribute([MarshalAs(UnmanagedType.Interface)] nsISecureBrowserUI aSecurityUI);
		
		/// <summary>
        /// Cancel the XPCOM timers for each meta-refresh URI in this docshell,
        /// and this docshell's children, recursively. The meta-refresh timers can be
        /// restarted using resumeRefreshURIs().  If the timers are already suspended,
        /// this has no effect.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SuspendRefreshURIs();
		
		/// <summary>
        /// Restart the XPCOM timers for each meta-refresh URI in this docshell,
        /// and this docshell's children, recursively.  If the timers are already
        /// running, this has no effect.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ResumeRefreshURIs();
		
		/// <summary>
        /// Begin firing WebProgressListener notifications for restoring a page
        /// presentation. |viewer| is the content viewer whose document we are
        /// starting to load.  If null, it defaults to the docshell's current content
        /// viewer, creating one if necessary.  |top| should be true for the toplevel
        /// docshell that is being restored; it will be set to false when this method
        /// is called for child docshells.  This method will post an event to
        /// complete the simulated load after returning to the event loop.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void BeginRestore([MarshalAs(UnmanagedType.Interface)] nsIContentViewer viewer, [MarshalAs(UnmanagedType.U1)] bool top);
		
		/// <summary>
        /// Finish firing WebProgressListener notifications and DOM events for
        /// restoring a page presentation.  This should only be called via
        /// beginRestore().
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void FinishRestore();
		
		/// <summary>
        ///Track whether we're currently restoring a document presentation. </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetRestoringDocumentAttribute();
		
		/// <summary>
        ///attribute to access whether error pages are enabled </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetUseErrorPagesAttribute();
		
		/// <summary>
        ///attribute to access whether error pages are enabled </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetUseErrorPagesAttribute([MarshalAs(UnmanagedType.U1)] bool aUseErrorPages);
		
		/// <summary>
        /// Keeps track of the previous SHTransaction index and the current
        /// SHTransaction index at the time that the doc shell begins to load.
        /// Used for ContentViewer eviction.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetPreviousTransIndexAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetLoadedTransIndexAttribute();
		
		/// <summary>
        /// Notification that entries have been removed from the beginning of a
        /// nsSHistory which has this as its rootDocShell.
        ///
        /// @param numEntries - The number of entries removed
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void HistoryPurged(int numEntries);
		
		/// <summary>
        /// Retrieves the WebApps session storage object for the supplied principal.
        ///
        /// @param principal returns a storage for this principal
        /// @param documentURI new storage will be created with reference to this
        /// document.documentURI that will appear in storage event
        /// @param create If true and a session storage object doesn't
        /// already exist, a new one will be created.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMStorage GetSessionStorageForPrincipal([MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase documentURI, [MarshalAs(UnmanagedType.U1)] bool create);
		
		/// <summary>
        /// Add a WebApps session storage object to the docshell.
        ///
        /// @param principal the principal the storage object is associated with
        /// @param storage the storage object to add
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddSessionStorage([MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, [MarshalAs(UnmanagedType.Interface)] nsIDOMStorage storage);
		
		/// <summary>
        /// Clones all session storage objects and attaches them to the given docshell.
        /// Useful when duplicating tabs and their states.
        ///
        /// @param docShell the docshell to clone the sessionstorage objects to
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CloneSessionStoragesTo([MarshalAs(UnmanagedType.Interface)] nsIDocShell docShell);
		
		/// <summary>
        /// Removes all WebApps session storage objects attached to the docshell.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearSessionStorages();
		
		/// <summary>
        /// Gets the channel for the currently loaded document, if any.
        /// For a new document load, this will be the channel of the previous document
        /// until after OnLocationChange fires.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIChannel GetCurrentDocumentChannelAttribute();
		
		/// <summary>
        /// Set the offset of this child in its container.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetChildOffset(uint offset);
		
		/// <summary>
        /// Find out whether the docshell is currently in the middle of a page
        /// transition. This is set just before the pagehide/unload events fire.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsInUnloadAttribute();
		
		/// <summary>
        /// Find out if the currently loaded document came from a suspicious channel
        /// (such as a JAR channel where the server-returned content type isn't a
        /// known JAR type).
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetChannelIsUnsafeAttribute();
		
		/// <summary>
        /// This attribute determines whether Mixed Active Content is loaded on the
        /// document. When it is true, mixed active content was not blocked and has
        /// loaded (or is about to load) on the page. When it is false, mixed active content
        /// has not loaded on the page, either because there was no mixed active content
        /// requests on the page or such requests were blocked by nsMixedContentBlocker.
        /// This boolean is set to true in nsMixedContentBlocker if Mixed Active Content
        /// is allowed (either explicitly on the page by the user or when the about:config
        /// setting security.mixed_content.block_active_content is set to false).
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetHasMixedActiveContentLoadedAttribute();
		
		/// <summary>
        /// This attribute determines whether a document has Mixed Active Content
        /// that has been blocked from loading. When it is true, there is definitely
        /// mixed active content on a page that has been blocked by
        /// nsMixedContentBlocker.  When it is false, there may or may not be mixed
        /// active content on a page, but if there is, it will load. Note that if the
        /// about:config setting security.mixed_content.block_active_content is set
        /// false, this boolean will be false, since blocking active content has been
        /// disabled.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetHasMixedActiveContentBlockedAttribute();
		
		/// <summary>
        /// This attribute determines whether Mixed Display Content is loaded on the
        /// document. When it is true, mixed display content was not blocked and has
        /// loaded (or is about to load) on the page. Similar behavior to
        /// hasMixedActiveContentLoaded.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetHasMixedDisplayContentLoadedAttribute();
		
		/// <summary>
        /// This attribute determines whether a document has Mixed Display Content
        /// that has been blocked from loading. Similar behavior to
        /// hasMixedActiveContentBlocked.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetHasMixedDisplayContentBlockedAttribute();
		
		/// <summary>
        /// Disconnects this docshell's editor from its window, and stores the
        /// editor data in the open document's session history entry.  This
        /// should be called only during page transitions.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DetachEditorFromWindow();
		
		/// <summary>
        /// If true, this browser is not visible in the traditional sense, but
        /// is actively being rendered to the screen (ex. painted on a canvas)
        /// and should be treated accordingly.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsOffScreenBrowserAttribute();
		
		/// <summary>
        /// If true, this browser is not visible in the traditional sense, but
        /// is actively being rendered to the screen (ex. painted on a canvas)
        /// and should be treated accordingly.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIsOffScreenBrowserAttribute([MarshalAs(UnmanagedType.U1)] bool aIsOffScreenBrowser);
		
		/// <summary>
        /// If the current content viewer isn't initialized for print preview,
        /// it is replaced with one which is and to which an about:blank document
        /// is loaded.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIWebBrowserPrint GetPrintPreviewAttribute();
		
		/// <summary>
        /// Whether this docshell can execute scripts based on its hierarchy.
        /// The rule of thumb here is that we disable js if this docshell or any
        /// of its parents disallow scripting, unless the only reason for js being
        /// disabled in this docshell is a parent docshell having a document that
        /// is in design mode.  In that case, we explicitly allow scripting on the
        /// current docshell.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetCanExecuteScriptsAttribute();
		
		/// <summary>
        /// Sets whether a docshell is active. An active docshell is one that is
        /// visible, and thus is not a good candidate for certain optimizations
        /// like image frame discarding. Docshells are active unless told otherwise.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsActiveAttribute();
		
		/// <summary>
        /// Sets whether a docshell is active. An active docshell is one that is
        /// visible, and thus is not a good candidate for certain optimizations
        /// like image frame discarding. Docshells are active unless told otherwise.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIsActiveAttribute([MarshalAs(UnmanagedType.U1)] bool aIsActive);
		
		/// <summary>
        /// The ID of the docshell in the session history.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ulong GetHistoryIDAttribute();
		
		/// <summary>
        /// Sets whether a docshell is an app tab. An app tab docshell may behave
        /// differently than a non-app tab docshell in some cases, such as when
        /// handling link clicks. Docshells are not app tabs unless told otherwise.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsAppTabAttribute();
		
		/// <summary>
        /// Sets whether a docshell is an app tab. An app tab docshell may behave
        /// differently than a non-app tab docshell in some cases, such as when
        /// handling link clicks. Docshells are not app tabs unless told otherwise.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIsAppTabAttribute([MarshalAs(UnmanagedType.U1)] bool aIsAppTab);
		
		/// <summary>
        /// Create a new about:blank document and content viewer.
        /// @param aPrincipal the principal to use for the new document.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CreateAboutBlankContentViewer([MarshalAs(UnmanagedType.Interface)] nsIPrincipal aPrincipal);
		
		/// <summary>
        /// The charset attribute allows the user to view, hint, and set which
        /// converter is used to read the document's data.
        ///
        /// <P>Inside Mozilla all text is encoded as Unicode. By standardizing
        /// on Unicode every piece of code that handles characters no longer
        /// needs to:
        ///
        /// Have access to a character encoding parameter.
        /// Ask is the data stateful?
        /// Ask is the data single byte?
        /// Ask is the data multi-byte?
        /// If multi-byte: have access to a routine that can
        /// determine how many bytes in the current character.
        ///
        /// When the document is read in a converter is used to convert
        /// the document's data to Unicode.
        ///
        /// The charset attribute provides the ability to:
        ///
        /// See what converter was used when inputting the documents
        /// data.
        ///
        /// Override the character set for documents where the specified
        /// fallback, or auto-detected character set is incorrect
        ///
        /// Get/sets the encoding (converter) used to read the
        /// document. Get returns the encoding used. Set forces
        /// (overrides) the encoding. After forcing the charset the
        /// embedding application will need to cause the data to be
        /// reparsed in order to update the DOM / display.
        ///
        /// A force also sets the fallback encoding for this frame.
        /// </summary>
		[return: MarshalAs(UnmanagedType.LPStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetCharsetAttribute();
		
		/// <summary>
        /// The charset attribute allows the user to view, hint, and set which
        /// converter is used to read the document's data.
        ///
        /// <P>Inside Mozilla all text is encoded as Unicode. By standardizing
        /// on Unicode every piece of code that handles characters no longer
        /// needs to:
        ///
        /// Have access to a character encoding parameter.
        /// Ask is the data stateful?
        /// Ask is the data single byte?
        /// Ask is the data multi-byte?
        /// If multi-byte: have access to a routine that can
        /// determine how many bytes in the current character.
        ///
        /// When the document is read in a converter is used to convert
        /// the document's data to Unicode.
        ///
        /// The charset attribute provides the ability to:
        ///
        /// See what converter was used when inputting the documents
        /// data.
        ///
        /// Override the character set for documents where the specified
        /// fallback, or auto-detected character set is incorrect
        ///
        /// Get/sets the encoding (converter) used to read the
        /// document. Get returns the encoding used. Set forces
        /// (overrides) the encoding. After forcing the charset the
        /// embedding application will need to cause the data to be
        /// reparsed in order to update the DOM / display.
        ///
        /// A force also sets the fallback encoding for this frame.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetCharsetAttribute([MarshalAs(UnmanagedType.LPStr)] string aCharset);
		
		/// <summary>
        /// Called when the user chose an encoding override from the character
        /// encoding menu. Separate from the setter for the charset property to avoid
        /// extensions adding noise to the data.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GatherCharsetMenuTelemetry();
		
		/// <summary>
        /// The charset forced by the user. When the charset attribute is set this
        /// attribute is set to the same value.
        ///
        /// XXX Could this be replaced by a boolean?
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIAtom GetForcedCharsetAttribute();
		
		/// <summary>
        /// The charset forced by the user. When the charset attribute is set this
        /// attribute is set to the same value.
        ///
        /// XXX Could this be replaced by a boolean?
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetForcedCharsetAttribute([MarshalAs(UnmanagedType.Interface)] nsIAtom aForcedCharset);
		
		/// <summary>
        /// In a child docshell, this is the charset of the parent docshell
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIAtom GetParentCharsetAttribute();
		
		/// <summary>
        /// In a child docshell, this is the charset of the parent docshell
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetParentCharsetAttribute([MarshalAs(UnmanagedType.Interface)] nsIAtom aParentCharset);
		
		/// <summary>
        /// In a child docshell, this is the source of parentCharset
        /// @see nsCharsetSource.h
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetParentCharsetSourceAttribute();
		
		/// <summary>
        /// In a child docshell, this is the source of parentCharset
        /// @see nsCharsetSource.h
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetParentCharsetSourceAttribute(int aParentCharsetSource);
		
		/// <summary>
        /// Add an observer to the list of parties to be notified when this docshell's
        /// private browsing status is changed. |obs| must support weak references.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AddWeakPrivacyTransitionObserver([MarshalAs(UnmanagedType.Interface)] nsIPrivacyTransitionObserver obs);
		
		/// <summary>
        /// Returns true if this docshell corresponds to an <iframe mozbrowser>.
        /// (<iframe mozapp mozbrowser> is not considered a browser.)
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsBrowserElementAttribute();
		
		/// <summary>
        /// Returns true iff the docshell corresponds to an <iframe mozapp>.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsAppAttribute();
		
		/// <summary>
        /// Returns isBrowserElement || isApp.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsBrowserOrAppAttribute();
		
		/// <summary>
        /// Returns true if this docshell corresponds to an <iframe mozbrowser> or if
        /// the docshell is contained in an <iframe mozbrowser>.  (<iframe mozapp
        /// mozbrowser> does not count as a browser.)
        ///
        /// Our notion here of "contained in" means: Walk up the docshell hierarchy in
        /// this process until we hit an <iframe mozapp> or <iframe mozbrowser> (or
        /// until the hierarchy ends).  Return true iff the docshell we stopped on has
        /// isBrowserElement == true.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsInBrowserElementAttribute();
		
		/// <summary>
        /// Returns true if this docshell corresponds to an <iframe mozbrowser> or
        /// <iframe mozap>, or if this docshell is contained in an <iframe mozbrowser>
        /// or <iframe mozapp>.
        ///
        /// To compute this value, we walk up the docshell hierarchy.  If we encounter
        /// a docshell with isBrowserElement or isApp before we hit the end of the
        /// hierarchy, we return true.  Otherwise, we return false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsInBrowserOrAppAttribute();
		
		/// <summary>
        /// Indicate that this docshell corresponds to an app with the given app id.
        ///
        /// You may pass NO_APP_ID or UNKNOWN_APP_ID for containingAppId.  If you
        /// pass NO_APP_ID, then this docshell will return NO_APP_ID for appId.  If
        /// you pass UNKNOWN_APP_ID, then this docshell will search its hiearchy for
        /// an app frame and use that frame's appId.
        ///
        /// You can call this method more than once, but there's no guarantee that
        /// other components will update their view of the world if you change a
        /// docshell's app id, so tread lightly.
        ///
        /// If you call this method after calling setIsBrowserInsideApp, this
        /// docshell will forget the fact that it was a browser.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIsApp(uint ownAppId);
		
		/// <summary>
        /// Indicate that this docshell corresponds to a browser inside an app with
        /// the given ID.  As with setIsApp, you may pass NO_APP_ID or
        /// UNKNOWN_APP_ID.
        ///
        /// As with setIsApp, you may call this more than once, but it's kind of a
        /// hack, so be careful.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIsBrowserInsideApp(uint containingAppId);
		
		/// <summary>
        /// Returns the id of the app associated with this docshell.  If this docshell
        /// is an <iframe mozbrowser> inside an <iframe mozapp>, we return the app's
        /// appId.
        ///
        /// We compute this value by walking up the docshell hierarchy until we find a
        /// docshell on which setIsApp(x) or setIsBrowserInsideApp(x) was called
        /// (ignoring those docshells where x == UNKNOWN_APP_ID).  We return the app
        /// id x.
        ///
        /// If we don't find a docshell with an associated app id in our hierarchy, we
        /// return NO_APP_ID.  We never return UNKNOWN_APP_ID.
        ///
        /// Notice that a docshell may have an associated app even if it returns true
        /// for isBrowserElement!
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetAppIdAttribute();
		
		/// <summary>
        /// Like nsIDocShellTreeItem::GetSameTypeParent, except this ignores <iframe
        /// mozbrowser> and <iframe mozapp> boundaries.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDocShell GetSameTypeParentIgnoreBrowserAndAppBoundaries();
		
		/// <summary>
        /// True iff asynchronous panning and zooming is enabled for this
        /// docshell.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAsyncPanZoomEnabledAttribute();
		
		/// <summary>
        /// The sandbox flags on the docshell. These reflect the value of the sandbox
        /// attribute of the associated IFRAME or CSP-protectable content, if
        /// existent. See the HTML5 spec for more details.
        /// These flags on the docshell reflect the current state of the sandbox
        /// attribute, which is modifiable. They are only used when loading new
        /// content, sandbox flags are also immutably set on the document when it is
        /// loaded.
        /// The sandbox flags of a document depend on the sandbox flags on its
        /// docshell and of its parent document, if any.
        /// See nsSandboxFlags.h for the possible flags.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetSandboxFlagsAttribute();
		
		/// <summary>
        /// The sandbox flags on the docshell. These reflect the value of the sandbox
        /// attribute of the associated IFRAME or CSP-protectable content, if
        /// existent. See the HTML5 spec for more details.
        /// These flags on the docshell reflect the current state of the sandbox
        /// attribute, which is modifiable. They are only used when loading new
        /// content, sandbox flags are also immutably set on the document when it is
        /// loaded.
        /// The sandbox flags of a document depend on the sandbox flags on its
        /// docshell and of its parent document, if any.
        /// See nsSandboxFlags.h for the possible flags.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetSandboxFlagsAttribute(uint aSandboxFlags);
		
		/// <summary>
        /// This member variable determines whether a document has Mixed Active Content that
        /// was initially blocked from loading, but the user has choosen to override the
        /// block and allow the content to load. mMixedContentChannel is set to the document's
        /// channel when the user allows mixed content. The nsMixedContentBlocker content policy
        /// checks if the document's root channel matches the mMixedContentChannel.  If it matches,
        /// then Mixed Content is loaded.  If it does match, mixed content is blocked.
        ///
        /// A match implies that there is definitely mixed active content on a page that was
        /// initially blocked by nsMixedContentBlocker and then allowed and loaded by the user.
        /// A miss imples that IF there is mixed active content on the page AND it was
        /// blocked by nsMixedContentBlocker.cpp, the user has not choosen to override
        /// the block. Note that if the about:config setting
        /// security.mixed_content.block_active_content is set to false, this boolean
        /// will be false, mMixedContentChannel will remain null since blocking active content has
        /// been disabled and hence mMixedContentChannel will never be set.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIChannel GetMixedContentChannelAttribute();
		
		/// <summary>
        /// This member variable determines whether a document has Mixed Active Content that
        /// was initially blocked from loading, but the user has choosen to override the
        /// block and allow the content to load. mMixedContentChannel is set to the document's
        /// channel when the user allows mixed content. The nsMixedContentBlocker content policy
        /// checks if the document's root channel matches the mMixedContentChannel.  If it matches,
        /// then Mixed Content is loaded.  If it does match, mixed content is blocked.
        ///
        /// A match implies that there is definitely mixed active content on a page that was
        /// initially blocked by nsMixedContentBlocker and then allowed and loaded by the user.
        /// A miss imples that IF there is mixed active content on the page AND it was
        /// blocked by nsMixedContentBlocker.cpp, the user has not choosen to override
        /// the block. Note that if the about:config setting
        /// security.mixed_content.block_active_content is set to false, this boolean
        /// will be false, mMixedContentChannel will remain null since blocking active content has
        /// been disabled and hence mMixedContentChannel will never be set.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetMixedContentChannelAttribute([MarshalAs(UnmanagedType.Interface)] nsIChannel aMixedContentChannel);
		
		/// <summary>
        /// Checks whether the channel associated with the root docShell is equal to
        /// mMixedContentChannel. If they are the same, allowMixedContent is set to true.
        /// Checks if the root document has a secure connection. If it is, sets
        /// rootHasSecureConnection to true. If the docShell is the root doc shell,
        /// isRootDocShell is set to true.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetAllowMixedContentAndConnectionData([MarshalAs(UnmanagedType.U1)] ref bool rootHasSecureConnection, [MarshalAs(UnmanagedType.U1)] ref bool allowMixedContent, [MarshalAs(UnmanagedType.U1)] ref bool isRootDocShell);
		
		/// <summary>
        /// Are plugins allowed in the current document loaded in this docshell ?
        /// (if there is one). This depends on whether plugins are allowed by this
        /// docshell itself or if the document is sandboxed and hence plugins should
        /// not be allowed.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool PluginsAllowedInCurrentDoc();
		
		/// <summary>
        /// Attribute that determines whether fullscreen is allowed to be entered for
        /// this subtree of the docshell tree. This is true when all iframes containing
        /// this docshell have their "allowfullscreen" attribute set to "true".
        /// fullscreenAllowed is only writable at content boundaries, where it is used
        /// to propagate the value of the cross process parent's iframe's
        /// "allowfullscreen" attribute to the child process. Setting
        /// fullscreenAllowed on docshells which aren't content boundaries throws an
        /// exception.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetFullscreenAllowedAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetFullscreenAllowed([MarshalAs(UnmanagedType.U1)] bool allowed);
		
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetAffectPrivateSessionLifetimeAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetAffectPrivateSessionLifetimeAttribute([MarshalAs(UnmanagedType.U1)] bool aAffectPrivateSessionLifetime);
		
		/// <summary>
        /// Indicates whether the UI may enable the character encoding menu. The UI
        /// must disable the menu when this property is false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetMayEnableCharacterEncodingMenuAttribute();
		
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIEditor GetEditorAttribute();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetEditorAttribute([MarshalAs(UnmanagedType.Interface)] nsIEditor aEditor);
		
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetEditableAttribute();
		
		/// <summary>
        ///this docShell is editable </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetHasEditingSessionAttribute();
		
		/// <summary>
        /// Make this docShell editable, setting a flag that causes
        /// an editor to get created, either immediately, or after
        /// a url has been loaded.
        /// @param  inWaitForUriLoad    true to wait for a URI before
        /// creating the editor.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void MakeEditable([MarshalAs(UnmanagedType.U1)] bool inWaitForUriLoad);
	}
	
	/// <summary>nsIDocShellConsts </summary>
	public class nsIDocShellConsts
	{
		
		// 
		public const long INTERNAL_LOAD_FLAGS_NONE = 0x0;
		
		// 
		public const long INTERNAL_LOAD_FLAGS_INHERIT_OWNER = 0x1;
		
		// 
		public const long INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER = 0x2;
		
		// 
		public const long INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP = 0x4;
		
		// <summary>
        // @see nsIWebNavigation::LOAD_FLAGS_FIRST_LOAD
        // </summary>
		public const long INTERNAL_LOAD_FLAGS_FIRST_LOAD = 0x8;
		
		// 
		public const long INTERNAL_LOAD_FLAGS_BYPASS_CLASSIFIER = 0x10;
		
		// 
		public const long INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES = 0x20;
		
		// <summary>
        // Get an enumerator over this docShell and its children.
        //
        // @param aItemType  - Only include docShells of this type, or if typeAll,
        // include all child shells.
        // Uses types from nsIDocShellTreeItem.
        // @param aDirection - Whether to enumerate forwards or backwards.
        // </summary>
		public const long ENUMERATE_FORWARDS = 0;
		
		// 
		public const long ENUMERATE_BACKWARDS = 1;
		
		// <summary>
        // The type of application that created this window
        // </summary>
		public const ulong APP_TYPE_UNKNOWN = 0;
		
		// 
		public const ulong APP_TYPE_MAIL = 1;
		
		// 
		public const ulong APP_TYPE_EDITOR = 2;
		
		// <summary>
        // Current busy state for DocShell
        // </summary>
		public const ulong BUSY_FLAGS_NONE = 0;
		
		// 
		public const ulong BUSY_FLAGS_BUSY = 1;
		
		// 
		public const ulong BUSY_FLAGS_BEFORE_PAGE_LOAD = 2;
		
		// 
		public const ulong BUSY_FLAGS_PAGE_LOADING = 4;
		
		// <summary>
        // Load commands for the document
        // </summary>
		public const ulong LOAD_CMD_NORMAL = 0x1;
		
		// <summary>
        // Normal load
        // </summary>
		public const ulong LOAD_CMD_RELOAD = 0x2;
		
		// <summary>
        // Reload
        // </summary>
		public const ulong LOAD_CMD_HISTORY = 0x4;
		
		// <summary>
        // Load from history
        // </summary>
		public const ulong LOAD_CMD_PUSHSTATE = 0x8;
	}
}
