// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIDOMWindowUtils.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
    /// nsIDOMWindowUtils is intended for infrequently-used methods related
    /// to the current nsIDOMWindow.  Some of the methods may require
    /// elevated privileges; the method implementations should contain the
    /// necessary security checks.  Access this interface by calling
    /// getInterface on a DOMWindow.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("ab9e9c45-1910-458c-a043-79cbbfc89f4d")]
	public interface nsIDOMWindowUtils
	{
		
		/// <summary>
        /// Image animation mode of the window. When this attribute's value
        /// is changed, the implementation should set all images in the window
        /// to the given value. That is, when set to kDontAnimMode, all images
        /// will stop animating. The attribute's value must be one of the
        /// animationMode values from imgIContainer.
        /// @note Images may individually override the window's setting after
        /// the window's mode is set. Therefore images given different modes
        /// since the last setting of the window's mode may behave
        /// out of line with the window's overall mode.
        /// @note The attribute's value is the window's overall mode. It may
        /// for example continue to report kDontAnimMode after all images
        /// have subsequently been individually animated.
        /// @note Only images immediately in this window are affected;
        /// this is not recursive to subwindows.
        /// @see imgIContainer
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ushort GetImageAnimationModeAttribute();
		
		/// <summary>
        /// Image animation mode of the window. When this attribute's value
        /// is changed, the implementation should set all images in the window
        /// to the given value. That is, when set to kDontAnimMode, all images
        /// will stop animating. The attribute's value must be one of the
        /// animationMode values from imgIContainer.
        /// @note Images may individually override the window's setting after
        /// the window's mode is set. Therefore images given different modes
        /// since the last setting of the window's mode may behave
        /// out of line with the window's overall mode.
        /// @note The attribute's value is the window's overall mode. It may
        /// for example continue to report kDontAnimMode after all images
        /// have subsequently been individually animated.
        /// @note Only images immediately in this window are affected;
        /// this is not recursive to subwindows.
        /// @see imgIContainer
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetImageAnimationModeAttribute(ushort aImageAnimationMode);
		
		/// <summary>
        /// Whether the charset of the window's current document has been forced by
        /// the user.
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetDocCharsetIsForcedAttribute();
		
		/// <summary>
        /// Get current cursor type from this window
        /// @return the current value of nsCursor
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		short GetCursorType();
		
		/// <summary>
        /// Function to get metadata associated with the window's current document
        /// @param aName the name of the metadata.  This should be all lowercase.
        /// @return the value of the metadata, or the empty string if it's not set
        ///
        /// Will throw a DOM security error if called without chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetDocumentMetadata([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aName, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase retval);
		
		/// <summary>
        /// Force an immediate redraw of this window.  The parameter specifies
        /// the number of times to redraw, and the return value is the length,
        /// in milliseconds, that the redraws took.  If aCount is not specified
        /// or is 0, it is taken to be 1.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint Redraw(uint aCount);
		
		/// <summary>
        /// Set the CSS viewport to be |widthPx| x |heightPx| in units of CSS
        /// pixels, regardless of the size of the enclosing widget/view.
        /// This will trigger reflow.
        ///
        /// The caller of this method must have chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetCSSViewport(float aWidthPx, float aHeightPx);
		
		/// <summary>
        /// Information retrieved from the <meta name="viewport"> tag.
        /// See nsContentUtils::GetViewportInfo for more information.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetViewportInfo(uint aDisplayWidth, uint aDisplayHeight, ref double aDefaultZoom, [MarshalAs(UnmanagedType.U1)] ref bool aAllowZoom, ref double aMinZoom, ref double aMaxZoom, ref uint aWidth, ref uint aHeight, [MarshalAs(UnmanagedType.U1)] ref bool aAutoSize);
		
		/// <summary>
        /// For any scrollable element, this allows you to override the
        /// visible region and draw more than what is visible, which is
        /// useful for asynchronous drawing. The "displayport" will be
        /// <xPx, yPx, widthPx, heightPx> in units of CSS pixels,
        /// regardless of the size of the enclosing container.  This
        /// will *not* trigger reflow.
        ///
        /// For the root scroll area, pass in the root document element.
        /// For scrollable elements, pass in the container element (for
        /// instance, the element with overflow: scroll).
        ///
        /// <x, y> is relative to the top-left of what would normally be
        /// the visible area of the element. This means that the pixels
        /// rendered to the displayport take scrolling into account,
        /// for example.
        ///
        /// It's legal to set a displayport that extends beyond the overflow
        /// area in any direction (left/right/top/bottom).
        ///
        /// It's also legal to set a displayport that extends beyond the
        /// area's bounds.  No pixels are rendered outside the area bounds.
        ///
        /// The caller of this method must have chrome privileges.
        ///
        /// Calling this will always force a recomposite, so it should be
        /// avoided if at all possible. Client code should do checks before
        /// calling this so that duplicate sets are not made with the same
        /// displayport.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDisplayPortForElement(float aXPx, float aYPx, float aWidthPx, float aHeightPx, [MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// When a display port is set, this allows a sub-section of that
        /// display port to be marked as 'critical'. In this scenario, the
        /// area outside of this rectangle may be rendered at a lower
        /// detail (for example, by reducing its resolution), or not rendered
        /// at all under some circumstances.
        /// This call will have no effect if a display port has not been set.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetCriticalDisplayPortForElement(float aXPx, float aYPx, float aWidthPx, float aHeightPx, [MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// Get/set the resolution at which rescalable web content is drawn.
        /// Currently this is only (some) thebes content.
        ///
        /// Setting a new resolution does *not* trigger reflow.  This API is
        /// entirely separate from textZoom and fullZoom; a resolution scale
        /// can be applied together with both textZoom and fullZoom.
        ///
        /// The effect of is API for gfx code to allocate more or fewer
        /// pixels for rescalable content by a factor of |resolution| in
        /// either or both dimensions.  setResolution() together with
        /// setDisplayport() can be used to implement a non-reflowing
        /// scale-zoom in concert with another entity that can draw with a
        /// scale.  For example, to scale a content |window| inside a
        /// <browser> by a factor of 2.0
        ///
        /// window.setDisplayport(x, y, oldW / 2.0, oldH / 2.0);
        /// window.setResolution(2.0, 2.0);
        /// // elsewhere
        /// browser.setViewportScale(2.0, 2.0);
        ///
        /// The caller of this method must have chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetResolution(float aXResolution, float aYResolution);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetResolution(ref float aXResolution, ref float aYResolution);
		
		/// <summary>
        /// Whether the next paint should be flagged as the first paint for a document.
        /// This gives a way to track the next paint that occurs after the flag is
        /// set. The flag gets cleared after the next paint.
        ///
        /// Can only be accessed with chrome privileges.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsFirstPaintAttribute();
		
		/// <summary>
        /// Whether the next paint should be flagged as the first paint for a document.
        /// This gives a way to track the next paint that occurs after the flag is
        /// set. The flag gets cleared after the next paint.
        ///
        /// Can only be accessed with chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetIsFirstPaintAttribute([MarshalAs(UnmanagedType.U1)] bool aIsFirstPaint);
		
		/// <summary>
        ///Synthesize a mouse event. The event types supported are:
        /// mousedown, mouseup, mousemove, mouseover, mouseout, contextmenu,
        /// MozMouseHitTest
        ///
        /// Events are sent in coordinates offset by aX and aY from the window.
        ///
        /// Note that additional events may be fired as a result of this call. For
        /// instance, typically a click event will be fired as a result of a
        /// mousedown and mouseup in sequence.
        ///
        /// Normally at this level of events, the mouseover and mouseout events are
        /// only fired when the window is entered or exited. For inter-element
        /// mouseover and mouseout events, a movemove event fired on the new element
        /// should be sufficient to generate the correct over and out events as well.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// The event is dispatched via the toplevel window, so it could go to any
        /// window under the toplevel window, in some cases it could never reach this
        /// window at all.
        ///
        /// @param aType event type
        /// @param aX x offset in CSS pixels
        /// @param aY y offset in CSS pixels
        /// @param aButton button to synthesize
        /// @param aClickCount number of clicks that have been performed
        /// @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
        /// @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
        /// during dispatch
        /// @param aPressure touch input pressure: 0.0 -> 1.0
        /// @param aInputSourceArg input source, see nsIDOMMouseEvent for values,
        /// defaults to mouse input.
        ///
        /// returns true if the page called prevent default on this event
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendMouseEvent([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aType, float aX, float aY, int aButton, int aClickCount, int aModifiers, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, float aPressure, ushort aInputSourceArg);
		
		/// <summary>
        ///Synthesize a touch event. The event types supported are:
        /// touchstart, touchend, touchmove, and touchcancel
        ///
        /// Events are sent in coordinates offset by aX and aY from the window.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// The event is dispatched via the toplevel window, so it could go to any
        /// window under the toplevel window, in some cases it could never reach this
        /// window at all.
        ///
        /// @param aType event type
        /// @param xs array of offsets in CSS pixels for each touch to be sent
        /// @param ys array of offsets in CSS pixels for each touch to be sent
        /// @param rxs array of radii in CSS pixels for each touch to be sent
        /// @param rys array of radii in CSS pixels for each touch to be sent
        /// @param rotationAngles array of angles in degrees for each touch to be sent
        /// @param forces array of forces (floats from 0 to 1) for each touch to be sent
        /// @param count number of touches in this set
        /// @param aModifiers modifiers pressed, using constants defined as MODIFIER_*
        /// @param aIgnoreRootScrollFrame whether the event should ignore viewport bounds
        /// during dispatch
        ///
        /// returns true if the page called prevent default on this touch event
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendTouchEvent([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aType, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] uint[] aIdentifiers, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] int[] aXs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] int[] aYs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] uint[] aRxs, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] uint[] aRys, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] float[] aRotationAngles, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=8)] float[] aForces, uint count, int aModifiers, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame);
		
		/// <summary>
        ///The same as sendMouseEvent but ensures that the event is dispatched to
        /// this DOM window or one of its children.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendMouseEventToWindow([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aType, float aX, float aY, int aButton, int aClickCount, int aModifiers, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, float aPressure, ushort aInputSourceArg);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendWheelEvent(float aX, float aY, double aDeltaX, double aDeltaY, double aDeltaZ, uint aDeltaMode, int aModifiers, int aLineOrPageDeltaX, int aLineOrPageDeltaY, uint aOptions);
		
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendKeyEvent([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aType, int aKeyCode, int aCharCode, int aModifiers, uint aAdditionalFlags);
		
		/// <summary>
        /// See nsIWidget::SynthesizeNativeKeyEvent
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// When you use this for tests, use the constants defined in NativeKeyCodes.js
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendNativeKeyEvent(int aNativeKeyboardLayout, int aNativeKeyCode, int aModifierFlags, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aCharacters, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aUnmodifiedCharacters);
		
		/// <summary>
        /// See nsIWidget::SynthesizeNativeMouseEvent
        ///
        /// Will be called on the widget that contains aElement.
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendNativeMouseEvent(int aScreenX, int aScreenY, int aNativeMessage, int aModifierFlags, [MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// See nsIWidget::SynthesizeNativeMouseScrollEvent
        ///
        /// Will be called on the widget that contains aElement.
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// NOTE: The synthesized native event may be fired asynchronously.
        ///
        /// @param aNativeMessage
        /// On Windows:  WM_MOUSEWHEEL (0x020A), WM_MOUSEHWHEEL(0x020E),
        /// WM_VSCROLL (0x0115) or WM_HSCROLL (0x114).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendNativeMouseScrollEvent(int aScreenX, int aScreenY, uint aNativeMessage, double aDeltaX, double aDeltaY, double aDeltaZ, uint aModifierFlags, uint aAdditionalFlags, [MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// See nsIWidget::ActivateNativeMenuItemAt
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ActivateNativeMenuItemAt([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase indexString);
		
		/// <summary>
        /// See nsIWidget::ForceUpdateNativeMenuAt
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ForceUpdateNativeMenuAt([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase indexString);
		
		/// <summary>
        /// Focus the element aElement. The element should be in the same document
        /// that the window is displaying. Pass null to blur the element, if any,
        /// that currently has focus, and focus the document.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// @param aElement the element to focus
        ///
        /// Do not use this method. Just use element.focus if available or
        /// nsIFocusManager::SetFocus instead.
        ///
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Focus([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// Force a garbage collection followed by a cycle collection.
        ///
        /// Will throw a DOM security error if called without chrome privileges in
        /// non-debug builds. Available to all callers in debug builds.
        ///
        /// @param aListener listener that receives information about the CC graph
        /// (see @mozilla.org/cycle-collector-logger;1 for a logger
        /// component)
        /// @param aExtraForgetSkippableCalls indicates how many times
        /// nsCycleCollector_forgetSkippable will
        /// be called before running cycle collection.
        /// -1 prevents the default
        /// nsCycleCollector_forgetSkippable call
        /// which happens after garbage collection.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GarbageCollect([MarshalAs(UnmanagedType.Interface)] nsICycleCollectorListener aListener, int aExtraForgetSkippableCalls);
		
		/// <summary>
        /// Force a cycle collection without garbage collection.
        ///
        /// Will throw a DOM security error if called without chrome privileges in
        /// non-debug builds. Available to all callers in debug builds.
        ///
        /// @param aListener listener that receives information about the CC graph
        /// (see @mozilla.org/cycle-collector-logger;1 for a logger
        /// component)
        /// @param aExtraForgetSkippableCalls indicates how many times
        /// nsCycleCollector_forgetSkippable will
        /// be called before running cycle collection.
        /// -1 prevents the default
        /// nsCycleCollector_forgetSkippable call
        /// which happens after garbage collection.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CycleCollect([MarshalAs(UnmanagedType.Interface)] nsICycleCollectorListener aListener, int aExtraForgetSkippableCalls);
		
		/// <summary>
        ///Synthesize a simple gesture event for a window. The event types
        /// supported are: MozSwipeGesture, MozMagnifyGestureStart,
        /// MozMagnifyGestureUpdate, MozMagnifyGesture, MozRotateGestureStart,
        /// MozRotateGestureUpdate, MozRotateGesture, MozPressTapGesture,
        /// MozTapGesture, and MozEdgeUIGesture.
        ///
        /// Cannot be accessed from unprivileged context (not
        /// content-accessible) Will throw a DOM security error if called
        /// without chrome privileges.
        ///
        /// @param aType event type
        /// @param aX x offset in CSS pixels
        /// @param aY y offset in CSS pixels
        /// @param aDirection direction, using constants defined in nsIDOMSimpleGestureEvent
        /// @param aDelta  amount of magnification or rotation for magnify and rotation events
        /// @param aModifiers modifiers pressed, using constants defined in nsIDOMNSEvent
        /// @param aClickCount For tap gestures, the number of taps.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendSimpleGestureEvent([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aType, float aX, float aY, uint aDirection, double aDelta, int aModifiers, uint aClickCount);
		
		/// <summary>
        /// Retrieve the element at point aX, aY in the window's document.
        ///
        /// @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
        /// frame when retrieving the element. If false, this method returns
        /// null for coordinates outside of the viewport.
        /// @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMElement ElementFromPoint(float aX, float aY, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, [MarshalAs(UnmanagedType.U1)] bool aFlushLayout);
		
		/// <summary>
        /// Retrieve all nodes that intersect a rect in the window's document.
        ///
        /// @param aX x reference for the rectangle in CSS pixels
        /// @param aY y reference for the rectangle in CSS pixels
        /// @param aTopSize How much to expand up the rectangle
        /// @param aRightSize How much to expand right the rectangle
        /// @param aBottomSize How much to expand down the rectangle
        /// @param aLeftSize How much to expand left the rectangle
        /// @param aIgnoreRootScrollFrame whether or not to ignore the root scroll
        /// frame when retrieving the element. If false, this method returns
        /// null for coordinates outside of the viewport.
        /// @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMNodeList NodesFromRect(float aX, float aY, float aTopSize, float aRightSize, float aBottomSize, float aLeftSize, [MarshalAs(UnmanagedType.U1)] bool aIgnoreRootScrollFrame, [MarshalAs(UnmanagedType.U1)] bool aFlushLayout);
		
		/// <summary>
        /// Compare the two canvases, returning the number of differing pixels and
        /// the maximum difference in a channel.  This will throw an error if
        /// the dimensions of the two canvases are different.
        ///
        /// This method requires chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint CompareCanvases([MarshalAs(UnmanagedType.Interface)] nsIDOMHTMLCanvasElement aCanvas1, [MarshalAs(UnmanagedType.Interface)] nsIDOMHTMLCanvasElement aCanvas2, ref uint aMaxDifference);
		
		/// <summary>
        /// Returns true if a MozAfterPaint event has been queued but not yet
        /// fired.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsMozAfterPaintPendingAttribute();
		
		/// <summary>
        /// Suppresses/unsuppresses user initiated event handling in window's document
        /// and subdocuments.
        ///
        /// @throw NS_ERROR_DOM_SECURITY_ERR if called without chrome privileges and
        /// NS_ERROR_FAILURE if window doesn't have a document.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SuppressEventHandling([MarshalAs(UnmanagedType.U1)] bool aSuppress);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearMozAfterPaintEvents();
		
		/// <summary>
        /// Disable or enable non synthetic test mouse events on *all* windows.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible).
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// @param aDisable  If true, disable all non synthetic test mouse events
        /// on all windows.  Otherwise, enable them.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DisableNonTestMouseEvents([MarshalAs(UnmanagedType.U1)] bool aDisable);
		
		/// <summary>
        /// Returns the scroll position of the window's currently loaded document.
        ///
        /// @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
        /// @see nsIDOMWindow::scrollX/Y
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetScrollXY([MarshalAs(UnmanagedType.U1)] bool aFlushLayout, ref int aScrollX, ref int aScrollY);
		
		/// <summary>
        /// Returns the scrollbar width of the window's scroll frame.
        ///
        /// @param aFlushLayout flushes layout if true. Otherwise, no flush occurs.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetScrollbarSize([MarshalAs(UnmanagedType.U1)] bool aFlushLayout, ref int aWidth, ref int aHeight);
		
		/// <summary>
        /// Returns the bounds of the window's currently loaded document. This will
        /// generally be (0, 0, pageWidth, pageHeight) but in some cases (e.g. RTL
        /// documents) may have a negative left value.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMClientRect GetRootBounds();
		
		/// <summary>
        /// Get IME open state. TRUE means 'Open', otherwise, 'Close'.
        /// This property works only when IMEEnabled is IME_STATUS_ENABLED.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIMEIsOpenAttribute();
		
		/// <summary>
        /// Get IME status, see above IME_STATUS_* definitions.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetIMEStatusAttribute();
		
		/// <summary>
        /// Get the number of screen pixels per CSS pixel.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		float GetScreenPixelsPerCSSPixelAttribute();
		
		/// <summary>
        /// Get the current zoom factor.
        /// This is _approximately_ the same as nsIMarkupDocumentViewer.fullZoom,
        /// but takes into account Gecko's quantization of the zoom factor, which is
        /// implemented by adjusting the (integer) number of appUnits per devPixel.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		float GetFullZoomAttribute();
		
		/// <summary>
        /// Dispatches aEvent via the nsIPresShell object of the window's document.
        /// The event is dispatched to aTarget, which should be an object
        /// which implements nsIContent interface (#element, #text, etc).
        ///
        /// Cannot be accessed from unprivileged context (not
        /// content-accessible) Will throw a DOM security error if called
        /// without chrome privileges.
        ///
        /// @note Event handlers won't get aEvent as parameter, but a similar event.
        /// Also, aEvent should not be reused.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool DispatchDOMEventViaPresShell([MarshalAs(UnmanagedType.Interface)] nsIDOMNode aTarget, [MarshalAs(UnmanagedType.Interface)] nsIDOMEvent aEvent, [MarshalAs(UnmanagedType.U1)] bool aTrusted);
		
		/// <summary>
        /// Sets nsEvent::mFlags::mOnlyChromeDispatch to true to ensure that
        /// the event is propagated only to chrome.
        /// Event's .target property will be aTarget.
        /// Returns the same value as what EventTarget.dispatchEvent does.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool DispatchEventToChromeOnly([MarshalAs(UnmanagedType.Interface)] nsIDOMEventTarget aTarget, [MarshalAs(UnmanagedType.Interface)] nsIDOMEvent aEvent);
		
		/// <summary>
        /// Returns the real classname (possibly of the mostly-transparent security
        /// wrapper) of aObj.
        /// </summary>
		[return: MarshalAs(UnmanagedType.LPStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetClassName(Gecko.JsVal aObject, System.IntPtr jsContext);
		
		/// <summary>
        /// Generate a content command event.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// @param aType Type of command content event to send.  Can be one of "cut",
        /// "copy", "paste", "delete", "undo", "redo", or "pasteTransferable".
        /// @param aTransferable an instance of nsITransferable when aType is
        /// "pasteTransferable"
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendContentCommandEvent([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aType, [MarshalAs(UnmanagedType.Interface)] nsITransferable aTransferable);
		
		/// <summary>
        /// Synthesize a composition event to the window.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible)
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// @param aType     The event type: "compositionstart", "compositionend" or
        /// "compositionupdate".
        /// @param aData     The data property value.  Note that this isn't applied
        /// for compositionstart event because its value is the
        /// selected text which is automatically computed.
        /// @param aLocale   The locale property value.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendCompositionEvent([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aType, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aData, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aLocale);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SendTextEvent([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aCompositionString, int aFirstClauseLength, uint aFirstClauseAttr, int aSecondClauseLength, uint aSecondClauseAttr, int aThirdClauseLength, uint aThirdClauseAttr, int aCaretStart, int aCaretLength);
		
		/// <summary>
        /// Synthesize a query content event.
        ///
        /// @param aType  One of the following const values.  And see also each comment
        /// for the other parameters and the result.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIQueryContentEventResult SendQueryContentEvent(uint aType, uint aOffset, uint aLength, int aX, int aY);
		
		/// <summary>
        /// Called when the remote child frame has changed its fullscreen state,
        /// when entering fullscreen, and when the origin which is fullscreen changes.
        /// aFrameElement is the iframe element which contains the child-process
        /// fullscreen document, and aNewOrigin is the origin of the new fullscreen
        /// document.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoteFrameFullscreenChanged([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aFrameElement, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aNewOrigin);
		
		/// <summary>
        /// Called when the remote frame has popped all fullscreen elements off its
        /// stack, so that the operation can complete on the parent side.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoteFrameFullscreenReverted();
		
		/// <summary>
        /// Called when the child frame has fully exit fullscreen, so that the parent
        /// process can also fully exit.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ExitFullscreen();
		
		/// <summary>
        /// Synthesize a selection set event to the window.
        ///
        /// This sets the selection as the specified information.
        ///
        /// @param aOffset  The caret offset of the selection start.
        /// @param aLength  The length of the selection.  If this is too long, the
        /// extra length is ignored.
        /// @param aReverse If true, the selection set from |aOffset + aLength| to
        /// |aOffset|.  Otherwise, set from |aOffset| to
        /// |aOffset + aLength|.
        /// @return True, if succeeded.  Otherwise, false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SendSelectionSetEvent(uint aOffset, uint aLength, [MarshalAs(UnmanagedType.U1)] bool aReverse);
		
		/// <summary>
        /// Select content at a client point based on a selection behavior if the
        /// underlying content is selectable. Selection will accumulate with any
        /// existing selection, callers should clear selection prior if needed.
        /// May fire selection changed events. Calls nsFrame's SelectByTypeAtPoint.
        ///
        /// @param aX, aY The selection point in client coordinates.
        /// @param aSelectType The selection behavior requested.
        /// @return True if a selection occured, false otherwise.
        /// @throw NS_ERROR_DOM_SECURITY_ERR, NS_ERROR_UNEXPECTED for utils
        /// issues, and NS_ERROR_INVALID_ARG for coordinates that are outside
        /// this window.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SelectAtPoint(float aX, float aY, uint aSelectBehavior);
		
		/// <summary>
        /// Perform the equivalent of:
        /// window.getComputedStyle(aElement, aPseudoElement).
        /// getPropertyValue(aPropertyName)
        /// except that, when the link whose presence in history is allowed to
        /// influence aElement's style is visited, get the value the property
        /// would have if allowed all properties to change as a result of
        /// :visited selectors (except for cases where getComputedStyle uses
        /// data from the frame).
        ///
        /// This is easier to implement than adding our property restrictions
        /// to this API, and is sufficient for the present testing
        /// requirements (which are essentially testing 'color').
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetVisitedDependentComputedStyle([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aPseudoElement, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aPropertyName, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase retval);
		
		/// <summary>
        /// Returns the parent of obj.
        ///
        /// @param obj The JavaScript object whose parent is to be gotten.
        /// @return the parent.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetParent(Gecko.JsVal obj, System.IntPtr jsContext);
		
		/// <summary>
        /// Get the id of the outer window of this window.  This will never throw.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ulong GetOuterWindowIDAttribute();
		
		/// <summary>
        /// Get the id of the current inner window of this window.  If there
        /// is no current inner window, throws NS_ERROR_NOT_AVAILABLE.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		ulong GetCurrentInnerWindowIDAttribute();
		
		/// <summary>
        /// Put the window into a state where scripts are frozen and events
        /// suppressed, for use when the window has launched a modal prompt.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnterModalState();
		
		/// <summary>
        /// Resume normal window state, where scripts can run and events are
        /// delivered.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LeaveModalState();
		
		/// <summary>
        /// Same as enterModalState, but returns the window associated with the
        /// current JS context.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMWindow EnterModalStateWithWindow();
		
		/// <summary>
        /// Same as leaveModalState, but takes a window associated with the active
        /// context when enterModalStateWithWindow was called. The currently context
        /// might be different at the moment (see bug 621764).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LeaveModalStateWithWindow([MarshalAs(UnmanagedType.Interface)] nsIDOMWindow aWindow);
		
		/// <summary>
        /// Is the window is in a modal state? [See enterModalState()]
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsInModalState();
		
		/// <summary>
        /// Suspend/resume timeouts on this window and its descendant windows.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SuspendTimeouts();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ResumeTimeouts();
		
		/// <summary>
        /// What type of layer manager the widget associated with this window is
        /// using. "Basic" is unaccelerated; other types are accelerated. Throws an
        /// error if there is no widget associated with this window.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetLayerManagerTypeAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aLayerManagerType);
		
		/// <summary>
        /// Returns a handle which represents current recording start position.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint StartFrameTimeRecording();
		
		/// <summary>
        /// Returns number of recorded frames since startIndex was issued,
        /// and allocates+populates 2 arraye with the recorded data.
        /// - Allocation is infallible. Should be released even if size is 0.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StopFrameTimeRecording(uint startIndex, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] ref float[] paintTimes, ref uint frameCount, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=2)] ref float[] frameIntervals);
		
		/// <summary>
        /// Signals that we're begining to tab switch. This is used by painting code to
        /// determine total tab switch time.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void BeginTabSwitch();
		
		/// <summary>
        /// The DPI of the display
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		float GetDisplayDPIAttribute();
		
		/// <summary>
        /// Return the outer window with the given ID, if any.  Can return null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMWindow GetOuterWindowWithId(ulong aOuterWindowID);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RenderDocument(nsConstRect aRect, uint aFlags, nscolor aBackgroundColor, gfxContext aThebesContext);
		
		/// <summary>
        /// advanceTimeAndRefresh allows the caller to take over the refresh
        /// driver timing for a window.  A call to advanceTimeAndRefresh does
        /// three things:
        /// (1) It marks the refresh driver for this presentation so that it
        /// no longer refreshes on its own, but is instead driven entirely
        /// by the caller (except for the refresh that happens when a
        /// document comes out of the bfcache).
        /// (2) It advances the refresh driver's current refresh time by the
        /// argument given.  Negative advances are permitted.
        /// (3) It does a refresh (i.e., notifies refresh observers) at that
        /// new time.
        ///
        /// Note that this affects other connected docshells of the same type
        /// in the same docshell tree, such as parent frames.
        ///
        /// When callers have completed their use of advanceTimeAndRefresh,
        /// they must call restoreNormalRefresh.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AdvanceTimeAndRefresh(long aMilliseconds);
		
		/// <summary>
        /// Undoes the effects of advanceTimeAndRefresh.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RestoreNormalRefresh();
		
		/// <summary>
        /// Reports whether the current state is test-controlled refreshes
        /// (see advanceTimeAndRefresh and restoreNormalRefresh above).
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsTestControllingRefreshesAttribute();
		
		/// <summary>
        /// Method for testing nsStyleAnimation::ComputeDistance.
        ///
        /// Returns the distance between the two values as reported by
        /// nsStyleAnimation::ComputeDistance for the given element and
        /// property.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double ComputeAnimationDistance([MarshalAs(UnmanagedType.Interface)] nsIDOMElement element, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase property, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase value1, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase value2);
		
		/// <summary>
        /// Wrap an nsIFile in an nsIDOMFile
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMFile WrapDOMFile([MarshalAs(UnmanagedType.Interface)] nsIFile aFile);
		
		/// <summary>
        /// Get the type of the currently focused html input, if any.
        /// </summary>
		[return: MarshalAs(UnmanagedType.LPStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetFocusedInputTypeAttribute();
		
		/// <summary>
        /// Given a view ID from the compositor process, retrieve the element
        /// associated with a view. For scrollpanes for documents, the root
        /// element of the document is returned.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMElement FindElementWithViewId(System.IntPtr aId);
		
		/// <summary>
        /// Checks the layer tree for this window and returns true
        /// if all layers have transforms that are translations by integers,
        /// no leaf layers overlap, and the union of the leaf layers is exactly
        /// the bounds of the window. Always returns true in non-DEBUG builds.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool LeafLayersPartitionWindow();
		
		/// <summary>
        /// true if the (current inner) window may have event listeners for touch events.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetMayHaveTouchEventListenersAttribute();
		
		/// <summary>
        /// Check if any ThebesLayer painting has been done for this element,
        /// clears the painted flags if they have.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool CheckAndClearPaintedState([MarshalAs(UnmanagedType.Interface)] nsIDOMElement aElement);
		
		/// <summary>
        /// Internal file constructor intended for testing of File objects.
        /// Example of constructor usage:
        /// getFile("myfile.txt", [b1, "foo"], { type: "text/plain" })
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMFile GetFile([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aName, Gecko.JsVal aBlobParts, Gecko.JsVal aParameters, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Internal blob constructor intended for testing of Blob objects.
        /// Example of constructor usage:
        /// getBlob([b1, "foo"], { type: "text/plain" })
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMBlob GetBlob(Gecko.JsVal aBlobParts, Gecko.JsVal aParameters, System.IntPtr jsContext, int argc);
		
		/// <summary>
        /// Get internal id of the stored blob, file or file handle.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetFileId(Gecko.JsVal aFile, System.IntPtr jsContext);
		
		/// <summary>
        /// Get file ref count info for given database and file id.
        ///
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetFileReferences([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aDatabaseName, long aId, ref int aRefCnt, ref int aDBRefCnt, ref int aSliceRefCnt);
		
		/// <summary>
        /// Return whether incremental GC has been disabled due to a binary add-on.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsIncrementalGCEnabled(System.IntPtr jsContext);
		
		/// <summary>
        /// Begin opcode-level profiling of all JavaScript execution in the window's
        /// runtime.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StartPCCountProfiling(System.IntPtr jsContext);
		
		/// <summary>
        /// Stop opcode-level profiling of JavaScript execution in the runtime, and
        /// collect all counts for use by getPCCount methods.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StopPCCountProfiling(System.IntPtr jsContext);
		
		/// <summary>
        /// Purge collected PC counters.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PurgePCCounts(System.IntPtr jsContext);
		
		/// <summary>
        /// Get the number of scripts with opcode-level profiling information.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetPCCountScriptCount(System.IntPtr jsContext);
		
		/// <summary>
        /// Get a JSON string for a short summary of a script and the PC counts
        /// accumulated for it.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPCCountScriptSummary(int script, System.IntPtr jsContext, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase retval);
		
		/// <summary>
        /// Get a JSON string with full information about a profiled script,
        /// including the decompilation of the script and placement of decompiled
        /// operations within it, and PC counts for each operation.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPCCountScriptContents(int script, System.IntPtr jsContext, [MarshalAs(UnmanagedType.LPStruct)] nsAStringBase retval);
		
		/// <summary>
        /// Returns true if painting is suppressed for this window and false
        /// otherwise.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetPaintingSuppressedAttribute();
		
		/// <summary>
        /// Returns an array of plugins on the page for opt-in activation.
        ///
        /// Cannot be accessed from unprivileged context (not content-accessible).
        /// Will throw a DOM security error if called without chrome privileges.
        ///
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetPluginsAttribute(System.IntPtr jsContext);
		
		/// <summary>
        /// Set the scrollport size for the purposes of clamping scroll positions for
        /// the root scroll frame of this document to be (aWidth,aHeight) in CSS pixels.
        ///
        /// The caller of this method must have chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetScrollPositionClampingScrollPortSize(float aWidth, float aHeight);
		
		/// <summary>
        /// Set margins for the layout of fixed position elements in the content
        /// document. These are used on mobile, where the viewable area can be
        /// temporarily obscured by the browser chrome. In this situation, we're ok
        /// with scrollable page content being obscured, but fixed position content
        /// cannot be revealed without removing the obscuring chrome, so we use these
        /// margins so that it can remain visible.
        ///
        /// The caller of this method must have chrome privileges.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetContentDocumentFixedPositionMargins(float aTop, float aRight, float aBottom, float aLeft);
		
		/// <summary>
        /// Prevent this window (and any child windows) from displaying any further
        /// dialogs (e.g. window.alert()).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PreventFurtherDialogs();
		
		/// <summary>
        /// Synchronously loads a style sheet from |sheetURI| and adds it to the list
        /// of additional style sheets of the document.
        ///
        /// These additional style sheets are very much like user/agent sheets loaded
        /// with loadAndRegisterSheet. The only difference is that they are applied only
        /// on the document owned by this window.
        ///
        /// Sheets added via this API take effect immediately on the document.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void LoadSheet([MarshalAs(UnmanagedType.Interface)] nsIURI sheetURI, uint type);
		
		/// <summary>
        /// Remove the document style sheet at |sheetURI| from the list of additional
        /// style sheets of the document.  The removal takes effect immediately.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveSheet([MarshalAs(UnmanagedType.Interface)] nsIURI sheetURI, uint type);
		
		/// <summary>
        /// Returns true if a user input is being handled.
        ///
        /// This calls nsEventStateManager::IsHandlingUserInput().
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsHandlingUserInputAttribute();
		
		/// <summary>
        /// After calling the method, the window for which this DOMWindowUtils
        /// was created can be closed using scripts.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AllowScriptsToClose();
		
		/// <summary>
        /// In certain cases the event handling of nodes, form controls in practice,
        /// may be disabled. Such cases are for example the existence of disabled
        /// attribute or -moz-user-input: none/disabled.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsNodeDisabledForEvents([MarshalAs(UnmanagedType.Interface)] nsIDOMNode aNode);
		
		/// <summary>
        /// Setting paintFlashing to true will flash newly painted area.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetPaintFlashingAttribute();
		
		/// <summary>
        /// Setting paintFlashing to true will flash newly painted area.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetPaintFlashingAttribute([MarshalAs(UnmanagedType.U1)] bool aPaintFlashing);
	}
	
	/// <summary>nsIDOMWindowUtilsConsts </summary>
	public class nsIDOMWindowUtilsConsts
	{
		
		// <summary>
        // Following modifiers are for sent*Event() except sendNative*Event().
        // NOTE: MODIFIER_ALT, MODIFIER_CONTROL, MODIFIER_SHIFT and MODIFIER_META
        // are must be same values as nsIDOMNSEvent::*_MASK for backward
        // compatibility.
        // </summary>
		public const long MODIFIER_ALT = 0x0001;
		
		// 
		public const long MODIFIER_CONTROL = 0x0002;
		
		// 
		public const long MODIFIER_SHIFT = 0x0004;
		
		// 
		public const long MODIFIER_META = 0x0008;
		
		// 
		public const long MODIFIER_ALTGRAPH = 0x0010;
		
		// 
		public const long MODIFIER_CAPSLOCK = 0x0020;
		
		// 
		public const long MODIFIER_FN = 0x0040;
		
		// 
		public const long MODIFIER_NUMLOCK = 0x0080;
		
		// 
		public const long MODIFIER_SCROLLLOCK = 0x0100;
		
		// 
		public const long MODIFIER_SYMBOLLOCK = 0x0200;
		
		// 
		public const long MODIFIER_OS = 0x0400;
		
		// <summary>
        //Synthesize a wheel event for a window. The event types supported is only
        // wheel.
        //
        // Events are sent in coordinates offset by aX and aY from the window.
        //
        // Cannot be accessed from unprivileged context (not content-accessible)
        // Will throw a DOM security error if called without chrome privileges.
        //
        // @param aX                 x offset in CSS pixels
        // @param aY                 y offset in CSS pixels
        // @param aDeltaX            deltaX value.
        // @param aDeltaY            deltaY value.
        // @param aDeltaZ            deltaZ value.
        // @param aDeltaMode         deltaMode value which must be one of
        // nsIDOMWheelEvent::DOM_DELTA_*.
        // @param aModifiers         modifiers pressed, using constants defined as
        // MODIFIER_*
        // @param aLineOrPageDeltaX  If you set this value non-zero for
        // DOM_DELTA_PIXEL event, nsEventStateManager will
        // dispatch NS_MOUSE_SCROLL event for horizontal
        // scroll.
        // @param aLineOrPageDeltaY  If you set this value non-zero for
        // DOM_DELTA_PIXEL event, nsEventStateManager will
        // dispatch NS_MOUSE_SCROLL event for vertical
        // scroll.
        // @param aOptions           Set following flags.
        // </summary>
		public const ulong WHEEL_EVENT_CAUSED_BY_PIXEL_ONLY_DEVICE = 0x0001;
		
		// 
		public const ulong WHEEL_EVENT_CAUSED_BY_MOMENTUM = 0x0002;
		
		// 
		public const ulong WHEEL_EVENT_CUSTOMIZED_BY_USER_PREFS = 0x0004;
		
		// <summary>
        // exception in case the relevant overflowDelta has an unexpected value.
        // </summary>
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_ZERO = 0x0010;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_POSITIVE = 0x0020;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_X_NEGATIVE = 0x0040;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_ZERO = 0x0100;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_POSITIVE = 0x0200;
		
		// 
		public const ulong WHEEL_EVENT_EXPECTED_OVERFLOW_DELTA_Y_NEGATIVE = 0x0400;
		
		// <summary>
        // If this is set, preventDefault() the event before dispatch.
        // </summary>
		public const ulong KEY_FLAG_PREVENT_DEFAULT = 0x0001;
		
		// <summary>
        // Otherwise, it will be computed from aKeyCode.
        // </summary>
		public const ulong KEY_FLAG_LOCATION_STANDARD = 0x0010;
		
		// 
		public const ulong KEY_FLAG_LOCATION_LEFT = 0x0020;
		
		// 
		public const ulong KEY_FLAG_LOCATION_RIGHT = 0x0040;
		
		// 
		public const ulong KEY_FLAG_LOCATION_NUMPAD = 0x0080;
		
		// 
		public const ulong KEY_FLAG_LOCATION_MOBILE = 0x0100;
		
		// 
		public const ulong KEY_FLAG_LOCATION_JOYSTICK = 0x0200;
		
		// <summary>
        // If MOUSESCROLL_PREFER_WIDGET_AT_POINT is set, widget will dispatch
        // the event to a widget which is under the cursor.  Otherwise, dispatch to
        // a default target on the platform.  E.g., on Windows, it's focused window.
        // </summary>
		public const ulong MOUSESCROLL_PREFER_WIDGET_AT_POINT = 0x00000001;
		
		// <summary>
        // If MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL is set and aNativeMessage is
        // WM_VSCROLL or WM_HSCROLL, widget will set the window handle to the lParam
        // instead of NULL.
        // </summary>
		public const ulong MOUSESCROLL_WIN_SCROLL_LPARAM_NOT_NULL = 0x00010000;
		
		// <summary>
        // DISABLED means users cannot use IME completely.
        // Note that this state is *not* same as |ime-mode: disabled;|.
        // </summary>
		public const ulong IME_STATUS_DISABLED = 0;
		
		// <summary>
        // ENABLED means users can use all functions of IME. This state is same as
        // |ime-mode: normal;|.
        // </summary>
		public const ulong IME_STATUS_ENABLED = 1;
		
		// <summary>
        // PASSWORD means users cannot use most functions of IME. But on GTK2,
        // users can use "Simple IM" which only supports dead key inputting.
        // The behavior is same as the behavior of the native password field.
        // This state is same as |ime-mode: disabled;|.
        // </summary>
		public const ulong IME_STATUS_PASSWORD = 2;
		
		// <summary>
        // PLUGIN means a plug-in has focus. At this time we should not touch to
        // controlling the IME state.
        // </summary>
		public const ulong IME_STATUS_PLUGIN = 3;
		
		// <summary>
        // NOTE: These values must be same to NS_TEXTRANGE_* in nsGUIEvent.h
        // </summary>
		public const ulong COMPOSITION_ATTR_RAWINPUT = 0x02;
		
		// 
		public const ulong COMPOSITION_ATTR_SELECTEDRAWTEXT = 0x03;
		
		// 
		public const ulong COMPOSITION_ATTR_CONVERTEDTEXT = 0x04;
		
		// 
		public const ulong COMPOSITION_ATTR_SELECTEDCONVERTEDTEXT = 0x05;
		
		// <summary>
        // QUERY_SELECTED_TEXT queries the first selection range's information.
        //
        // @param aOffset   Not used.
        // @param aLength   Not used.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return offset, reversed and text properties of the result are available.
        // </summary>
		public const ulong QUERY_SELECTED_TEXT = 3200;
		
		// <summary>
        // QUERY_TEXT_CONTENT queries the text at the specified range.
        //
        // @param aOffset   The first character's offset.  0 is the first character.
        // @param aLength   The length of getting text.  If the aLength is too long,
        // the result text is shorter than this value.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return text property of the result is available.
        // </summary>
		public const ulong QUERY_TEXT_CONTENT = 3201;
		
		// <summary>
        // QUERY_CARET_RECT queries the (collapsed) caret rect of the offset.
        // If the actual caret is there at the specified offset, this returns the
        // actual caret rect.  Otherwise, this guesses the caret rect from the
        // metrics of the text.
        //
        // @param aOffset   The caret offset.  0 is the left side of the first
        // caracter in LTR text.
        // @param aLength   Not used.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return left, top, width and height properties of the result are available.
        // The left and the top properties are offset in the client area of
        // the DOM window.
        // </summary>
		public const ulong QUERY_CARET_RECT = 3203;
		
		// <summary>
        // QUERY_TEXT_RECT queries the specified text's rect.
        //
        // @param aOffset   The first character's offset.  0 is the first character.
        // @param aLength   The length of getting text.  If the aLength is too long,
        // the extra length is ignored.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return left, top, width and height properties of the result are available.
        // The left and the top properties are offset in the client area of
        // the DOM window.
        // </summary>
		public const ulong QUERY_TEXT_RECT = 3204;
		
		// <summary>
        // QUERY_TEXT_RECT queries the focused editor's rect.
        //
        // @param aOffset   Not used.
        // @param aLength   Not used.
        // @param aX        Not used.
        // @param aY        Not used.
        //
        // @return left, top, width and height properties of the result are available.
        // </summary>
		public const ulong QUERY_EDITOR_RECT = 3205;
		
		// <summary>
        // QUERY_CHARACTER_AT_POINT queries the character information at the
        // specified point.  The point is offset in the window.
        // NOTE: If there are some panels at the point, this method send the query
        // event to the panel's widget automatically.
        //
        // @param aOffset   Not used.
        // @param aLength   Not used.
        // @param aX        X offset in the widget.
        // @param aY        Y offset in the widget.
        //
        // @return offset, notFound, left, top, width and height properties of the
        // result are available.
        // </summary>
		public const ulong QUERY_CHARACTER_AT_POINT = 3208;
		
		// <summary>
        //Selection behaviors - mirror nsIFrame's nsSelectionAmount constants </summary>
		public const ulong SELECT_CHARACTER = 0;
		
		// 
		public const ulong SELECT_CLUSTER = 1;
		
		// 
		public const ulong SELECT_WORD = 2;
		
		// 
		public const ulong SELECT_LINE = 3;
		
		// 
		public const ulong SELECT_BEGINLINE = 4;
		
		// 
		public const ulong SELECT_ENDLINE = 5;
		
		// 
		public const ulong SELECT_PARAGRAPH = 6;
		
		// 
		public const ulong SELECT_WORDNOSPACE = 7;
		
		// 
		public const ulong AGENT_SHEET = 0;
		
		// 
		public const ulong USER_SHEET = 1;
		
		// 
		public const ulong AUTHOR_SHEET = 2;
	}
}
