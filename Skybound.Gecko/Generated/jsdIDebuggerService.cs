// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file jsdIDebuggerService.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;

	
	
	/// <summary>
    /// Debugger service. It is not a good idea to have more than one active client
    /// of the debugger service.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("9be5b327-6818-464d-9695-f33885fd8377")]
	public interface jsdIDebuggerService
	{
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDContextAttribute();
		
		/// <summary>
        /// Called when an error or warning occurs.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIErrorHook GetErrorHookAttribute();
		
		/// <summary>
        /// Called when an error or warning occurs.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetErrorHookAttribute(jsdIErrorHook aErrorHook);
		
		/// <summary>
        /// Called when a jsdIScript is created or destroyed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIScriptHook GetScriptHookAttribute();
		
		/// <summary>
        /// Called when a jsdIScript is created or destroyed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetScriptHookAttribute(jsdIScriptHook aScriptHook);
		
		/// <summary>
        /// Called when the engine encounters a breakpoint.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIExecutionHook GetBreakpointHookAttribute();
		
		/// <summary>
        /// Called when the engine encounters a breakpoint.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetBreakpointHookAttribute(jsdIExecutionHook aBreakpointHook);
		
		/// <summary>
        /// Called when the engine encounters the debugger keyword.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIExecutionHook GetDebuggerHookAttribute();
		
		/// <summary>
        /// Called when the engine encounters the debugger keyword.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDebuggerHookAttribute(jsdIExecutionHook aDebuggerHook);
		
		/// <summary>
        /// Called when the errorHook returns false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIExecutionHook GetDebugHookAttribute();
		
		/// <summary>
        /// Called when the errorHook returns false.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDebugHookAttribute(jsdIExecutionHook aDebugHook);
		
		/// <summary>
        /// Called before the next PC is executed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIExecutionHook GetInterruptHookAttribute();
		
		/// <summary>
        /// Called before the next PC is executed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetInterruptHookAttribute(jsdIExecutionHook aInterruptHook);
		
		/// <summary>
        /// Called when an exception is thrown (even if it will be caught.)
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIExecutionHook GetThrowHookAttribute();
		
		/// <summary>
        /// Called when an exception is thrown (even if it will be caught.)
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetThrowHookAttribute(jsdIExecutionHook aThrowHook);
		
		/// <summary>
        /// Called before and after a toplevel script is evaluated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdICallHook GetTopLevelHookAttribute();
		
		/// <summary>
        /// Called before and after a toplevel script is evaluated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetTopLevelHookAttribute(jsdICallHook aTopLevelHook);
		
		/// <summary>
        /// Called before and after a function is called.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdICallHook GetFunctionHookAttribute();
		
		/// <summary>
        /// Called before and after a function is called.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetFunctionHookAttribute(jsdICallHook aFunctionHook);
		
		/// <summary>
        /// Debugger service flags.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetFlagsAttribute();
		
		/// <summary>
        /// Debugger service flags.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetFlagsAttribute(uint aFlags);
		
		/// <summary>
        /// Major version number of implementation.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetImplementationMajorAttribute();
		
		/// <summary>
        /// Minor version number of implementation.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetImplementationMinorAttribute();
		
		/// <summary>
        /// Free form AUTF8String identifier for implementation.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetImplementationStringAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aImplementationString);
		
		/// <summary>
        /// |true| if the debugger service has been turned on. This does not
        /// necessarily mean another app is actively using the service, as the
        /// autostart pref may have turned the service on.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsOnAttribute();
		
		/// <summary>
        /// Synchronous activation of the debugger is no longer supported,
        /// and will throw an exception.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void On();
		
		/// <summary>
        /// Turn on the debugger. This function should only be called from
        /// JavaScript code. The debugger will be enabled on the runtime the call is
        /// made on, as determined by nsIXPCNativeCallContext.
        ///
        /// The debugger will be activated asynchronously, because there can be no
        /// JS on the stack when code is to be re-compiled for debug mode.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AsyncOn(jsdIActivationCallback callback);
		
		/// <summary>
        /// Called by nsIXPConnect after it's had a chance to recompile for
        /// debug mode.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ActivateDebugger(System.IntPtr rt);
		
		/// <summary>
        /// Called by nsIXPConnect to deactivate debugger on setup failure.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DeactivateDebugger();
		
		/// <summary>
        /// Recompile all active scripts in the runtime for debugMode.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RecompileForDebugMode(System.IntPtr cx, System.IntPtr comp, [MarshalAs(UnmanagedType.U1)] bool mode);
		
		/// <summary>
        /// Turn the debugger off. This will invalidate all of your jsdIEphemeral
        /// derived objects, and clear all of your breakpoints.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Off();
		
		/// <summary>
        /// Peek at the current pause depth of the debugger.
        ///
        /// @return depth Number of pause() calls still waiting to be unPause()d.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetPauseDepthAttribute();
		
		/// <summary>
        /// Temporarily disable the debugger. Hooks will not be called while the
        /// debugger is paused. Multiple calls to pause will increase the "pause
        /// depth", and equal number of unPause calles must be made to resume
        /// normal debugging.
        ///
        /// @return depth Number of times pause has been called since the debugger
        /// has been unpaused.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint Pause();
		
		/// <summary>
        /// Undo a pause.  Once this is called, the debugger won't start
        /// getting execution callbacks until the stack is fully unwound so
        /// that no JS scripts are live.  There is no way to query whether
        /// there are such scripts left to unwind at a given point in time.
        ///
        /// @return depth The number of remaining pending pause calls.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint UnPause();
		
		/// <summary>
        /// Force the engine to perform garbage collection.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GC();
		
		/// <summary>
        /// Clear profile data for all scripts.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearProfileData();
		
		/// <summary>
        /// Adds an execution hook filter. These filters are consulted each time one
        /// of the jsdIExecutionHooks is about to be called. Filters are matched in
        /// a first in, first compared fashion. The first filter to match determines
        /// whether or not the hook is called. Use swapFilter to reorder existing
        /// filters, and removeFilter to remove them.
        ///
        /// If |filter| is already present this method throws NS_ERROR_INVALID_ARG.
        ///
        /// @param filter Object representing the filter to add.
        /// @param after  Insert |filter| after this one. Pass null to insert at
        /// the beginning.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InsertFilter(jsdIFilter filter, jsdIFilter after);
		
		/// <summary>
        /// Same as insertFilter, except always add to the end of the list.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void AppendFilter(jsdIFilter filter);
		
		/// <summary>
        /// Remove a filter.
        ///
        /// If |filter| is not present this method throws NS_ERROR_INVALID_ARG.
        ///
        /// @param filter Object representing the filter to remove. Must be the exact
        /// object passed to addFilter, not just a new object with the same
        /// properties.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RemoveFilter(jsdIFilter filter);
		
		/// <summary>
        /// Swap position of two filters.
        ///
        /// If |filter_a| is not present, this method throws NS_ERROR_INVALID_ARG.
        /// If |filter_b| is not present, filter_a is replaced by filter_b.
        /// If |filter_a| == |filter_b|, then filter is refreshed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SwapFilters(jsdIFilter filter_a, jsdIFilter filter_b);
		
		/// <summary>
        /// Enumerate registered filters. This routine refreshes each filter before
        /// passing them on to the enumeration function. Calling this with a null
        /// |enumerator| is equivalent to jsdIService::refreshFilters.
        ///
        /// @param enumerator jsdIFilterEnumerator instance to be called back for the
        /// enumeration.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnumerateFilters(jsdIFilterEnumerator enumerator);
		
		/// <summary>
        /// Force the debugger to resync its internal filter cache with the
        /// actual values in the jsdIFilter objects. To refresh a single filter
        /// use jsdIService::swapFilters. This method is equivalent to
        /// jsdIService::enumerateFilters with a null enumerator.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RefreshFilters();
		
		/// <summary>
        /// Clear the list of filters.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearFilters();
		
		/// <summary>
        /// Enumerate all known contexts.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnumerateContexts(jsdIContextEnumerator enumerator);
		
		/// <summary>
        /// Enumerate all scripts the debugger knows about. Any scripts created
        /// before you turned the debugger on, or after turning the debugger off
        /// will not be available unless the autostart perf is set.
        ///
        /// @param enumerator jsdIScriptEnumerator instance to be called back for
        /// the enumeration.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnumerateScripts(jsdIScriptEnumerator enumerator);
		
		/// <summary>
        /// Clear all breakpoints in all scripts.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearAllBreakpoints();
		
		/// <summary>
        /// When called from JavaScript, this method returns the jsdIValue wrapper
        /// for the given value. If a wrapper does not exist one will be created.
        /// When called from another language this method returns an xpconnect
        /// defined error code.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue WrapValue(Gecko.JsVal value);
		
		/// <summary>
        /// Push a new network queue, and enter a new UI event loop.
        /// @param callback jsdINestCallback instance to be called back after the
        /// network queue has been pushed, but before the
        /// UI loop starts.
        /// @return depth returns the current number of times the event loop has been
        /// nested. your code can use it for sanity checks.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint EnterNestedEventLoop(jsdINestCallback callback);
		
		/// <summary>
        /// Exit the current nested event loop after the current iteration completes,
        /// and pop the network event queue.
        ///
        /// @return depth returns the current number of times the event loop has been
        /// nested. your code can use it for sanity checks.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint ExitNestedEventLoop();
		
		/// <summary>
        /// Output dump of JS heap.
        ///
        /// @param fileName Filename to dump the heap into.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DumpHeap([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase fileName);
	}
	
	/// <summary>jsdIDebuggerServiceConsts </summary>
	public class jsdIDebuggerServiceConsts
	{
		
		// <summary>
        // Possible values for jsdIScript::version and jsdIContext::version.
        // </summary>
		public const long VERSION_1_0 = 100;
		
		// 
		public const long VERSION_1_1 = 110;
		
		// 
		public const long VERSION_1_2 = 120;
		
		// 
		public const long VERSION_1_3 = 130;
		
		// 
		public const long VERSION_1_4 = 140;
		
		// 
		public const long VERSION_1_5 = 150;
		
		// 
		public const long VERSION_DEFAULT = 0;
		
		// 
		public const long VERSION_UNKNOWN = -1;
		
		// <summary>
        // Link native frames in call stacks.
        // </summary>
		public const ulong ENABLE_NATIVE_FRAMES = 0x01;
		
		// <summary>
        // Normally, if a script has a 0 in JSD_SCRIPT_PROFILE_BIT it is included in
        // profile data, otherwise it is not profiled. Setting the
        // PROFILE_WHEN_SET flag reverses this convention.
        // </summary>
		public const ulong PROFILE_WHEN_SET = 0x02;
		
		// <summary>
        // Normally, when the script in the top frame of a thread state has a 1 in
        // JSD_SCRIPT_DEBUG_BIT, the execution hook is ignored. Setting the
        // DEBUG_WHEN_SET flag reverses this convention.
        // </summary>
		public const ulong DEBUG_WHEN_SET = 0x04;
		
		// <summary>
        // When this flag is set the internal call hook will collect profile data.
        // </summary>
		public const ulong COLLECT_PROFILE_DATA = 0x08;
		
		// <summary>
        // When this flag is set, stack frames that are disabled for debugging
        // will not appear in the call stack chain.
        // </summary>
		public const ulong HIDE_DISABLED_FRAMES = 0x10;
		
		// <summary>
        // When this flag is set, the debugger will only check the
        // JSD_SCRIPT_DEBUG_BIT on the top (most recent) stack frame. This
        // makes it possible to stop in an enabled frame which was called from
        // a stack that contains a disabled frame.
        //
        // When this flag is *not* set, any stack that contains a disabled frame
        // will not be debugged (the execution hook will not be invoked.)
        //
        // This only applies when the reason for calling the hook would have
        // been TYPE_INTERRUPTED or TYPE_THROW. TYPE_BREAKPOINT,
        // TYPE_DEBUG_REQUESTED, and TYPE_DEBUGGER_KEYWORD always stop, regardless
        // of this setting, as long as the top frame is not disabled.
        //
        // If HIDE_DISABLED_FRAMES is set, this is effectively set as well.
        // </summary>
		public const ulong MASK_TOP_FRAME_ONLY = 0x20;
		
		// <summary>
        // This flag has been retired, do not re-use. It previously provided a hook
        // for object allocation.
        // </summary>
		public const ulong DISABLE_OBJECT_TRACE_RETIRED = 0x40;
	}
	
	/// <summary>
    /// Object representing a pattern of global object and/or url the debugger should
    /// ignore. The debugger service itself will not modify properties of these
    /// objects.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("0c9189d9-4287-47a4-bca6-6ed65aaf737f")]
	public interface jsdIFilter
	{
		
		/// <summary>
        /// FLAG_* values from above, OR'd together.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetFlagsAttribute();
		
		/// <summary>
        /// FLAG_* values from above, OR'd together.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetFlagsAttribute(uint aFlags);
		
		/// <summary>
        /// An nsISupports version of the global object to be filtered. A null glob
        /// matches all hooks. This attribute must be QI'able to the
        /// (non-scriptable) nsIScriptGlobalObject interface.
        ///
        /// The jsdIService caches this value internally, so if it changes you must
        /// swap the filter with itself using jsdIService::swapFilters.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISupports GetGlobalObjectAttribute();
		
		/// <summary>
        /// An nsISupports version of the global object to be filtered. A null glob
        /// matches all hooks. This attribute must be QI'able to the
        /// (non-scriptable) nsIScriptGlobalObject interface.
        ///
        /// The jsdIService caches this value internally, so if it changes you must
        /// swap the filter with itself using jsdIService::swapFilters.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetGlobalObjectAttribute([MarshalAs(UnmanagedType.Interface)] nsISupports aGlobalObject);
		
		/// <summary>
        /// String representing the url pattern to be filtered. Supports limited
        /// glob matching, at the beginning and end of the pattern only. For example,
        /// "chrome://venkman*" filters all urls that start with chrome/venkman,
        /// "*.cgi" filters all cgi's, and "http://myserver/utils.js" filters only
        /// the utils.js file on "myserver". A null urlPattern matches all urls.
        ///
        /// The jsdIService caches this value internally, to if it changes you must
        /// swap the filter with itself using jsdIService::swapFilters.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetUrlPatternAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aUrlPattern);
		
		/// <summary>
        /// String representing the url pattern to be filtered. Supports limited
        /// glob matching, at the beginning and end of the pattern only. For example,
        /// "chrome://venkman*" filters all urls that start with chrome/venkman,
        /// "*.cgi" filters all cgi's, and "http://myserver/utils.js" filters only
        /// the utils.js file on "myserver". A null urlPattern matches all urls.
        ///
        /// The jsdIService caches this value internally, to if it changes you must
        /// swap the filter with itself using jsdIService::swapFilters.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetUrlPatternAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aUrlPattern);
		
		/// <summary>
        /// Line number for the start of this filter. Line numbers are one based.
        /// Assigning a 0 to this attribute will tell the debugger to ignore the
        /// entire file.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetStartLineAttribute();
		
		/// <summary>
        /// Line number for the start of this filter. Line numbers are one based.
        /// Assigning a 0 to this attribute will tell the debugger to ignore the
        /// entire file.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetStartLineAttribute(uint aStartLine);
		
		/// <summary>
        /// Line number for the end of this filter. Line numbers are one based.
        /// Assigning a 0 to this attribute will tell the debugger to ignore from
        /// |startLine| to the end of the file.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetEndLineAttribute();
		
		/// <summary>
        /// Line number for the end of this filter. Line numbers are one based.
        /// Assigning a 0 to this attribute will tell the debugger to ignore from
        /// |startLine| to the end of the file.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetEndLineAttribute(uint aEndLine);
	}
	
	/// <summary>jsdIFilterConsts </summary>
	public class jsdIFilterConsts
	{
		
		// <summary>
        // These two bytes of the flags attribute are reserved for interpretation
        // by the jsdService implementation. You can do what you like with the
        // remaining flags.
        // </summary>
		public const ulong FLAG_RESERVED_MASK = 0xFF;
		
		// <summary>
        // Filters without this flag set are ignored.
        // </summary>
		public const ulong FLAG_ENABLED = 0x01;
		
		// <summary>
        // Filters with this flag set are "pass" filters, they allow matching hooks
        // to continue. Filters without this flag block matching hooks.
        // </summary>
		public const ulong FLAG_PASS = 0x02;
	}
	
	/// <summary>
    /// Notify client code that debugMode has been activated.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("6da7f5fb-3a84-4abe-9e23-8b2045960732")]
	public interface jsdIActivationCallback
	{
		
		/// <summary>
        /// Notify client code that debugMode has been activated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void OnDebuggerActivated();
	}
	
	/// <summary>
    /// Pass an instance of one of these to jsdIDebuggerService::enterNestedEventLoop.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("88bea60f-9b5d-4b39-b08b-1c3a278782c6")]
	public interface jsdINestCallback
	{
		
		/// <summary>
        /// This method will be called after pre-nesting work has completed, such
        /// as pushing the js context and network event queue, but before the new
        /// event loop starts.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void OnNest();
	}
	
	/// <summary>
    /// Pass an instance of one of these to jsdIDebuggerService::enumerateFilters.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("e391ba85-9379-4762-b387-558e38db730f")]
	public interface jsdIFilterEnumerator
	{
		
		/// <summary>
        /// The enumerateFilter method will be called once for every filter the
        /// debugger knows about.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnumerateFilter(jsdIFilter filter);
	}
	
	/// <summary>
    /// Pass an instance of one of these to jsdIDebuggerService::enumerateScripts.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("4eef60c2-9bbc-48fa-b196-646a832c6c81")]
	public interface jsdIScriptEnumerator
	{
		
		/// <summary>
        /// The enumerateScript method will be called once for every script the
        /// debugger knows about.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnumerateScript(jsdIScript script);
	}
	
	/// <summary>
    /// Pass an instance of one of these to jsdIDebuggerService::enumerateContexts.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("57d18286-550c-4ca9-ac33-56f12ebba91e")]
	public interface jsdIContextEnumerator
	{
		
		/// <summary>
        /// The enumerateContext method will be called once for every context
        /// currently in use.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnumerateContext(jsdIContext executionContext);
	}
	
	/// <summary>
    /// Set jsdIDebuggerService::scriptHook to an instance of one of these.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("d030d1a2-a58a-4f19-b9e3-96da4e2cdd09")]
	public interface jsdIScriptHook
	{
		
		/// <summary>
        /// Called when scripts are created.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void OnScriptCreated(jsdIScript script);
		
		/// <summary>
        /// Called when the JavaScript engine destroys a script. The jsdIScript
        /// object passed in will already be invalidated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void OnScriptDestroyed(jsdIScript script);
	}
	
	/// <summary>
    /// Hook instances of this interface up to the
    /// jsdIDebuggerService::functionHook and toplevelHook properties.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("3eff1314-7ae3-4cf8-833b-c33c24a55633")]
	public interface jsdICallHook
	{
		
		/// <summary>
        /// Called before the JavaScript engine executes a top level script or calls
        /// a function.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void OnCall(jsdIStackFrame frame, uint type);
	}
	
	/// <summary>jsdICallHookConsts </summary>
	public class jsdICallHookConsts
	{
		
		// <summary>
        // Toplevel script is starting.
        // </summary>
		public const ulong TYPE_TOPLEVEL_START = 0;
		
		// <summary>
        // Toplevel script has completed.
        // </summary>
		public const ulong TYPE_TOPLEVEL_END = 1;
		
		// <summary>
        // Function is being called.
        // </summary>
		public const ulong TYPE_FUNCTION_CALL = 2;
		
		// <summary>
        // Function is returning.
        // </summary>
		public const ulong TYPE_FUNCTION_RETURN = 3;
	}
	
	/// <summary>jsdIErrorHook </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("e6b45eee-d974-4d85-9d9e-f5a67218deb4")]
	public interface jsdIErrorHook
	{
		
		/// <summary>
        /// Called when the JavaScript engine encounters an error. Return |true|
        /// to pass the error along, |false| to invoke the debugHook.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool OnError([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase message, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase fileName, uint line, uint pos, uint flags, uint errnum, jsdIValue exc);
	}
	
	/// <summary>jsdIErrorHookConsts </summary>
	public class jsdIErrorHookConsts
	{
		
		// <summary>
        // Report is an error.
        // </summary>
		public const ulong REPORT_ERROR = 0x00;
		
		// <summary>
        // Report is only a warning.
        // </summary>
		public const ulong REPORT_WARNING = 0x01;
		
		// <summary>
        // Report represents an uncaught exception.
        // </summary>
		public const ulong REPORT_EXCEPTION = 0x02;
		
		// <summary>
        // Report is due to strict mode.
        // </summary>
		public const ulong REPORT_STRICT = 0x04;
	}
	
	/// <summary>
    /// Hook instances of this interface up to the
    /// jsdIDebuggerService::breakpointHook, debuggerHook, errorHook, interruptHook,
    /// and throwHook properties.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("3a722496-9d78-4f0a-a797-293d9e8cb8d2")]
	public interface jsdIExecutionHook
	{
		
		/// <summary>
        /// @param frame A jsdIStackFrame object representing the bottom stack frame.
        /// @param type  One of the jsdIExecutionHook::TYPE_ constants.
        /// @param val   in  - Current exception (if any) when this method is called.
        /// out - If you return RETURN_THROW_WITH_VAL, value to be
        /// thrown.
        /// If you return RETURN_RET_WITH_VAL, value to return.
        /// All other return values, not significant.
        /// @retval      One of the jsdIExecutionHook::RETURN_* constants.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint OnExecute(jsdIStackFrame frame, uint type, ref jsdIValue val);
	}
	
	/// <summary>jsdIExecutionHookConsts </summary>
	public class jsdIExecutionHookConsts
	{
		
		// <summary>
        // Execution stopped because we're in single step mode.
        // </summary>
		public const ulong TYPE_INTERRUPTED = 0;
		
		// <summary>
        // Execution stopped by a trap instruction (i.e. breakoint.)
        // </summary>
		public const ulong TYPE_BREAKPOINT = 1;
		
		// <summary>
        // Error handler returned an "invoke debugger" value.
        // </summary>
		public const ulong TYPE_DEBUG_REQUESTED = 2;
		
		// <summary>
        // Debugger keyword encountered.
        // </summary>
		public const ulong TYPE_DEBUGGER_KEYWORD = 3;
		
		// <summary>
        // Exception was thrown.
        // </summary>
		public const ulong TYPE_THROW = 4;
		
		// <summary>
        // Indicates unrecoverable error processing the hook. This will cause
        // the script being executed to be aborted without raising a JavaScript
        // exception.
        // </summary>
		public const ulong RETURN_HOOK_ERROR = 0;
		
		// <summary>
        // Continue processing normally. This is the "do nothing special" return
        // value for all hook types *except* TYPE_THROW. Returning RETURN_CONTINUE
        // from TYPE_THROW cause the exception to be ignored. Return
        // RETURN_CONTINUE_THROW to continue exception processing from TYPE_THROW
        // hooks.
        // </summary>
		public const ulong RETURN_CONTINUE = 1;
		
		// <summary>
        // Same effect as RETURN_HOOK_ERROR.
        // </summary>
		public const ulong RETURN_ABORT = 2;
		
		// <summary>
        // Return the value of the |val| parameter.
        // </summary>
		public const ulong RETURN_RET_WITH_VAL = 3;
		
		// <summary>
        // Throw the value of the |val| parameter.
        // </summary>
		public const ulong RETURN_THROW_WITH_VAL = 4;
		
		// <summary>
        // Continue the current throw.
        // </summary>
		public const ulong RETURN_CONTINUE_THROW = 5;
	}
	
	/// <summary>
    /// Objects which inherit this interface may go away, with (jsdIScript) or
    /// without (all others) notification. These objects are generally wrappers
    /// around JSD structures that go away when you call jsdService::Off().
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("46f1e23e-1dd2-11b2-9ceb-8285f2e95e69")]
	public interface jsdIEphemeral
	{
		
		/// <summary>
        /// |true| if this object is still valid. If not, many or all of the methods
        /// and/or properties of the inheritor may no longer be callable.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsValidAttribute();
		
		/// <summary>
        /// Mark this instance as invalid.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Invalidate();
	}
	
	/// <summary>
    /// Context object. Only context's which are also nsISupports objects can be
    /// reflected by this interface.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("3e5c934d-6863-4d81-96f5-76a3b962fc2b")]
	public interface jsdIContext : jsdIEphemeral
	{
		
		/// <summary>
        /// |true| if this object is still valid. If not, many or all of the methods
        /// and/or properties of the inheritor may no longer be callable.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetIsValidAttribute();
		
		/// <summary>
        /// Mark this instance as invalid.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Invalidate();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSContextAttribute();
		
		/// <summary>
        /// OPT_* values above, OR'd together.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetOptionsAttribute();
		
		/// <summary>
        /// OPT_* values above, OR'd together.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetOptionsAttribute(uint aOptions);
		
		/// <summary>
        /// Last version set on this context.
        /// Scripts typically select this with the "language" attribute.
        /// See the VERSION_* consts on jsdIDebuggerService.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetVersionAttribute();
		
		/// <summary>
        /// Last version set on this context.
        /// Scripts typically select this with the "language" attribute.
        /// See the VERSION_* consts on jsdIDebuggerService.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetVersionAttribute(int aVersion);
		
		/// <summary>
        /// Unique tag among all valid jsdIContext objects, useful as a hash key.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetTagAttribute();
		
		/// <summary>
        /// Private data for this context, if it is an nsISupports, |null| otherwise.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISupports GetPrivateDataAttribute();
		
		/// <summary>
        /// Retrieve the underlying context wrapped by this jsdIContext.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISupports GetWrappedContextAttribute();
		
		/// <summary>
        /// Top of the scope chain for this context.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetGlobalObjectAttribute();
		
		/// <summary>
        /// |true| if this context should be allowed to run scripts, |false|
        /// otherwise. This attribute is only valid for contexts which implement
        /// nsIScriptContext. Setting or getting this attribute on any other
        /// context will throw a NS_ERROR_NO_INTERFACE exception.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetScriptsEnabledAttribute();
		
		/// <summary>
        /// |true| if this context should be allowed to run scripts, |false|
        /// otherwise. This attribute is only valid for contexts which implement
        /// nsIScriptContext. Setting or getting this attribute on any other
        /// context will throw a NS_ERROR_NO_INTERFACE exception.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetScriptsEnabledAttribute([MarshalAs(UnmanagedType.U1)] bool aScriptsEnabled);
	}
	
	/// <summary>jsdIContextConsts </summary>
	public class jsdIContextConsts
	{
		
		// <summary>
        // Strict mode is on.
        // </summary>
		public const long OPT_STRICT = 0x01;
		
		// <summary>
        // Warnings reported as errors.
        // </summary>
		public const long OPT_WERR = 0x02;
		
		// <summary>
        // Makes eval() use the last object on its 'obj' param's scope chain as the
        // ECMA 'variables object'.
        // </summary>
		public const long OPT_VAROBJFIX = 0x04;
		
		// <summary>
        // Private data for this object is an nsISupports object. Attempting to
        // alter this bit will result in an NS_ERROR_ILLEGAL_VALUE.
        // </summary>
		public const long OPT_ISUPPORTS = 0x08;
	}
	
	/// <summary>
    /// Stack frame objects. These are only valid inside the jsdIExecutionHook which
    /// gave it to you. After you return from that handler the bottom frame, and any
    /// frame you found attached through it, are invalidated via the jsdIEphemeral
    /// interface. Once a jsdIStackFrame has been invalidated all method and
    /// property accesses will throw a NS_ERROR_NOT_AVAILABLE exception.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("7c95422c-7579-4a6f-8ef7-e5b391552ee5")]
	public interface jsdIStackFrame : jsdIEphemeral
	{
		
		/// <summary>
        /// |true| if this object is still valid. If not, many or all of the methods
        /// and/or properties of the inheritor may no longer be callable.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetIsValidAttribute();
		
		/// <summary>
        /// Mark this instance as invalid.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Invalidate();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDContextAttribute();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDThreadStateAttribute();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDStackFrameInfoAttribute();
		
		/// <summary>
        /// True if stack frame represents a frame created as a result of a debugger
        /// evaluation.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsDebuggerAttribute();
		
		/// <summary>
        /// True if stack frame is constructing a new object.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsConstructingAttribute();
		
		/// <summary>
        /// Link to the caller's stack frame.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIStackFrame GetCallingFrameAttribute();
		
		/// <summary>
        /// Executon context.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIContext GetExecutionContextAttribute();
		
		/// <summary>
        /// Function name executing in this stack frame.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFunctionNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aFunctionName);
		
		/// <summary>
        /// Script running in this stack frame, null for native frames.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIScript GetScriptAttribute();
		
		/// <summary>
        /// Current program counter in this stack frame.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetPcAttribute();
		
		/// <summary>
        /// Current line number (using the script's pc to line map.)
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetLineAttribute();
		
		/// <summary>
        /// Function object running in this stack frame.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetCalleeAttribute();
		
		/// <summary>
        /// Top object in the scope chain.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetScopeAttribute();
		
		/// <summary>
        /// |this| object for this stack frame.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetThisValueAttribute();
		
		/// <summary>
        /// Evaluate arbitrary JavaScript in this stack frame.
        /// @param bytes    Script to be evaluated.
        /// @param fileName Filename to compile this script under. This is the
        /// filename you'll see in error messages, etc.
        /// @param line     Starting line number for this script. One based.
        /// @retval         Result of evaluating the script.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool Eval([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase bytes, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase fileName, uint line, ref jsdIValue result);
	}
	
	/// <summary>
    /// Script object. In JavaScript engine terms, there's a single script for each
    /// function, and one for the top level script.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("721724e0-7716-4bf4-b48f-92b78d056141")]
	public interface jsdIScript : jsdIEphemeral
	{
		
		/// <summary>
        /// |true| if this object is still valid. If not, many or all of the methods
        /// and/or properties of the inheritor may no longer be callable.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetIsValidAttribute();
		
		/// <summary>
        /// Mark this instance as invalid.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Invalidate();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDContextAttribute();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDScriptAttribute();
		
		/// <summary>
        /// Last version set on this context.
        /// Scripts typically select this with the "language" attribute.
        /// See the VERSION_* consts on jsdIDebuggerService.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetVersionAttribute();
		
		/// <summary>
        /// Tag value guaranteed unique among jsdIScript objects. Useful as a
        /// hash key in script.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetTagAttribute();
		
		/// <summary>
        /// FLAG_* attributes from above, OR'd together.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetFlagsAttribute();
		
		/// <summary>
        /// FLAG_* attributes from above, OR'd together.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetFlagsAttribute(uint aFlags);
		
		/// <summary>
        /// Filename given for this script when it was compiled.
        /// This data is copied from the underlying structure when the jsdIScript
        /// instance is created and is therefore available even after the script is
        /// invalidated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFileNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aFileName);
		
		/// <summary>
        /// Function name for this script. "anonymous" for unnamed functions (or
        /// a function actually named anonymous), empty for top level scripts.
        /// This data is copied from the underlying structure when the jsdIScript
        /// instance is created and is therefore available even after the script is
        /// invalidated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFunctionNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aFunctionName);
		
		/// <summary>
        /// The names of the arguments for this function; empty if this is
        /// not a function.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetParameterNames(ref uint count, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=0)] ref System.IntPtr[] paramNames);
		
		/// <summary>
        /// Fetch the function object as a jsdIValue.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetFunctionObjectAttribute();
		
		/// <summary>
        /// Source code for this script, without function declaration.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFunctionSourceAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAStringBase aFunctionSource);
		
		/// <summary>
        /// Line number in source file containing the first line of this script.
        /// This data is copied from the underlying structure when the jsdIScript
        /// instance is created and is therefore available even after the script is
        /// invalidated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetBaseLineNumberAttribute();
		
		/// <summary>
        /// Total number of lines in this script.
        /// This data is copied from the underlying structure when the jsdIScript
        /// instance is created and is therefore available even after the script is
        /// invalidated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetLineExtentAttribute();
		
		/// <summary>
        /// Number of times this script has been called.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetCallCountAttribute();
		
		/// <summary>
        /// Number of times this script called itself, directly or indirectly.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetMaxRecurseDepthAttribute();
		
		/// <summary>
        /// Shortest execution time recorded, in milliseconds.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double GetMinExecutionTimeAttribute();
		
		/// <summary>
        /// Longest execution time recorded, in milliseconds.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double GetMaxExecutionTimeAttribute();
		
		/// <summary>
        /// Total time spent in this function, in milliseconds.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double GetTotalExecutionTimeAttribute();
		
		/// <summary>
        /// Shortest execution time recorded, in milliseconds, excluding time spent
        /// in other called code.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double GetMinOwnExecutionTimeAttribute();
		
		/// <summary>
        /// Longest execution time recorded, in milliseconds, excluding time spent
        /// in other called code.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double GetMaxOwnExecutionTimeAttribute();
		
		/// <summary>
        /// Total time spent in this function, in milliseconds, excluding time spent
        /// in other called code.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double GetTotalOwnExecutionTimeAttribute();
		
		/// <summary>
        /// Clear profile data for this script.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearProfileData();
		
		/// <summary>
        /// Get the closest line number to a given PC.
        /// The |pcmap| argument specifies which pc to source line map to use.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint PcToLine(uint pc, uint pcmap);
		
		/// <summary>
        /// Get the first PC associated with a line.
        /// The |pcmap| argument specifies which pc to source line map to use.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint LineToPc(uint line, uint pcmap);
		
		/// <summary>
        /// Determine is a particular line is executable, like checking that
        /// lineToPc == pcToLine, except in one call.
        /// The |pcmap| argument specifies which pc to source line map to use.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsLineExecutable(uint line, uint pcmap);
		
		/// <summary>
        /// Return a list of all executable lines in a script.
        /// |pcmap| specifies which pc to source line map to use.
        /// |startLine| and |maxLines| may be used to retrieve a chunk at a time.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetExecutableLines(uint pcmap, uint startLine, uint maxLines, ref uint count, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex=3)] ref uint[] executableLines);
		
		/// <summary>
        /// Set a breakpoint at a PC in this script.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetBreakpoint(uint pc);
		
		/// <summary>
        /// Clear a breakpoint at a PC in this script.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearBreakpoint(uint pc);
		
		/// <summary>
        /// Clear all breakpoints set in this script.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ClearAllBreakpoints();
		
		/// <summary>
        /// Call interrupt hook at least once per source line
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnableSingleStepInterrupts([MarshalAs(UnmanagedType.U1)] bool mode);
	}
	
	/// <summary>jsdIScriptConsts </summary>
	public class jsdIScriptConsts
	{
		
		// <summary>
        // Determines whether or not to collect profile information for this
        // script. The context flag FLAG_PROFILE_WHEN_SET decides the logic.
        // </summary>
		public const ulong FLAG_PROFILE = 0x01;
		
		// <summary>
        // Determines whether or not to ignore breakpoints, etc. in this script.
        // The context flag JSD_DEBUG_WHEN_SET decides the logic.
        // </summary>
		public const ulong FLAG_DEBUG = 0x02;
		
		// 
		public const ulong PCMAP_SOURCETEXT = 1;
		
		// <summary>
        //map to actual source text </summary>
		public const ulong PCMAP_PRETTYPRINT = 2;
	}
	
	/// <summary>
    /// Value objects. Represents typeless JavaScript values (jsval in SpiderMonkey
    /// terminology.)  These are valid until the debugger is turned off. Holding a
    /// jsdIValue adds a root for the underlying JavaScript value, so don't keep it
    /// if you don't need to.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("1cd3535b-4ddb-4202-9053-e0ec88f5c82b")]
	public interface jsdIValue : jsdIEphemeral
	{
		
		/// <summary>
        /// |true| if this object is still valid. If not, many or all of the methods
        /// and/or properties of the inheritor may no longer be callable.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetIsValidAttribute();
		
		/// <summary>
        /// Mark this instance as invalid.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Invalidate();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDContextAttribute();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDValueAttribute();
		
		/// <summary>
        /// |false| unless the value is a function declared in script.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsNativeAttribute();
		
		/// <summary>
        /// |true| if the value represents a number, either double or integer.
        /// |false| for all other values, including numbers assigned as strings
        /// (eg. x = "1";)
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsNumberAttribute();
		
		/// <summary>
        /// |true| if the value represents a JavaScript primitive number or AUTF8String
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetIsPrimitiveAttribute();
		
		/// <summary>
        /// One of the TYPE_* values above.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetJsTypeAttribute();
		
		/// <summary>
        /// Prototype value if this value represents an object, null if the value is
        /// not an object or the object has no prototype.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetJsPrototypeAttribute();
		
		/// <summary>
        /// Parent value if this value represents an object, null if the value is not
        /// an object or the object has no parent.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetJsParentAttribute();
		
		/// <summary>
        /// Class name if this value represents an object. Empty AUTF8String if the value
        /// is not an object.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetJsClassNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aJsClassName);
		
		/// <summary>
        /// Constructor name if this value represents an object. Empty AUTF8String if the
        /// value is not an object.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetJsConstructorAttribute();
		
		/// <summary>
        /// Function name if this value represents a function. Empty AUTF8String if the
        /// value is not a function.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetJsFunctionNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aJsFunctionName);
		
		/// <summary>
        /// Value if interpreted as a boolean. Converts if necessary.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool GetBooleanValueAttribute();
		
		/// <summary>
        /// Value if interpreted as a double. Converts if necessary.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		double GetDoubleValueAttribute();
		
		/// <summary>
        /// Value if interpreted as an integer. Converts if necessary.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetIntValueAttribute();
		
		/// <summary>
        /// Value if interpreted as an object.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIObject GetObjectValueAttribute();
		
		/// <summary>
        /// Value if interpreted as a AUTF8String. Converts if necessary.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetStringValueAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aStringValue);
		
		/// <summary>
        /// Number of properties. 0 if the value is not an object, or the value is
        /// an object but has no properties.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetPropertyCountAttribute();
		
		/// <summary>
        /// Retrieves all properties if this value represents an object. If this
        /// value is not an object a 0 element array is returned.
        /// @param propArray Array of jsdIProperty values for this value.
        /// @param length    Size of array.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetProperties(ref System.IntPtr propArray, ref uint length);
		
		/// <summary>
        /// Retrieves a single property from the value. Only valid if the value
        /// represents an object.
        /// @param name Name of the property to retrieve.
        /// @retval     jsdIProperty for the requested property name or null if no
        /// property exists for the requested name.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetProperty([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase name);
		
		/// <summary>
        /// jsdIValues are wrappers around JavaScript engine structures. Much of the
        /// data is copied instead of shared. The refresh method is used to resync
        /// the jsdIValue with the underlying structure.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Refresh();
		
		/// <summary>
        /// When called from JavaScript, this method returns the JavaScript value
        /// wrapped by this jsdIValue. The calling script is free to use the result
        /// as it would any other JavaScript value.
        /// When called from another language this method returns an xpconnect
        /// defined error code.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		Gecko.JsVal GetWrappedValue(System.IntPtr jsContext);
		
		/// <summary>
        /// If this is a function value, return its associated jsdIScript.
        /// Otherwise, return null.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIScript GetScriptAttribute();
	}
	
	/// <summary>jsdIValueConsts </summary>
	public class jsdIValueConsts
	{
		
		// <summary>
        //Value is either |true| or |false|. </summary>
		public const ulong TYPE_BOOLEAN = 0;
		
		// <summary>
        //Value is a primitive number that is too large to fit in an integer. </summary>
		public const ulong TYPE_DOUBLE = 1;
		
		// <summary>
        //Value is a primitive number that fits into an integer. </summary>
		public const ulong TYPE_INT = 2;
		
		// <summary>
        //Value is a function. </summary>
		public const ulong TYPE_FUNCTION = 3;
		
		// <summary>
        //Value is |null|. </summary>
		public const ulong TYPE_NULL = 4;
		
		// <summary>
        //Value is an object. </summary>
		public const ulong TYPE_OBJECT = 5;
		
		// <summary>
        //Value is a primitive AUTF8String. </summary>
		public const ulong TYPE_STRING = 6;
		
		// <summary>
        //Value is void. </summary>
		public const ulong TYPE_VOID = 7;
	}
	
	/// <summary>
    /// Properties specific to values which are also objects.
    /// XXX We don't add roots for these yet, so make sure you hold on to the
    /// jsdIValue from whence your jsdIObject instance came for at least as long as
    /// you hold the jsdIObject.
    /// XXX Maybe the jsClassName, jsConstructorName, and property related attribute/
    /// functions from jsdIValue should move to this interface. We could inherit from
    /// jsdIValue or use interface flattening or something.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("87d86308-7a27-4255-b23c-ce2394f02473")]
	public interface jsdIObject
	{
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDContextAttribute();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDObjectAttribute();
		
		/// <summary>
        /// The URL (filename) that contains the script which caused this object
        /// to be created.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetCreatorURLAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aCreatorURL);
		
		/// <summary>
        /// Line number in the creatorURL where this object was created.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetCreatorLineAttribute();
		
		/// <summary>
        /// The URL (filename) that contains the script which defined the constructor
        /// used to create this object.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetConstructorURLAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aConstructorURL);
		
		/// <summary>
        /// Line number in the creatorURL where this object was created.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetConstructorLineAttribute();
		
		/// <summary>
        /// jsdIValue for this object.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetValueAttribute();
	}
	
	/// <summary>
    /// Representation of a property of an object. When an instance is invalid, all
    /// method and property access will result in a NS_UNAVAILABLE error.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("09332485-1419-42bc-ba1f-070815ed4b82")]
	public interface jsdIProperty : jsdIEphemeral
	{
		
		/// <summary>
        /// |true| if this object is still valid. If not, many or all of the methods
        /// and/or properties of the inheritor may no longer be callable.
        /// </summary>
		[return: MarshalAs(UnmanagedType.U1)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetIsValidAttribute();
		
		/// <summary>
        /// Mark this instance as invalid.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void Invalidate();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDContextAttribute();
		
		/// <summary>
        ///Internal use only. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetJSDPropertyAttribute();
		
		/// <summary>
        ///FLAG_* values OR'd together, representing the flags for this property. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetFlagsAttribute();
		
		/// <summary>
        ///jsdIValue representing the alias for this property. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetAliasAttribute();
		
		/// <summary>
        ///name for this property. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetNameAttribute();
		
		/// <summary>
        ///value of this property. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		jsdIValue GetValueAttribute();
		
		/// <summary>
        ///slot number if this property is a local variable or parameter. </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetVarArgSlotAttribute();
	}
	
	/// <summary>jsdIPropertyConsts </summary>
	public class jsdIPropertyConsts
	{
		
		// <summary>
        //visible to for/in loop </summary>
		public const ulong FLAG_ENUMERATE = 0x01;
		
		// <summary>
        //assignment is error </summary>
		public const ulong FLAG_READONLY = 0x02;
		
		// <summary>
        //property cannot be deleted </summary>
		public const ulong FLAG_PERMANENT = 0x04;
		
		// <summary>
        //property has an alias id </summary>
		public const ulong FLAG_ALIAS = 0x08;
		
		// <summary>
        //argument to function </summary>
		public const ulong FLAG_ARGUMENT = 0x10;
		
		// <summary>
        //local variable in function </summary>
		public const ulong FLAG_VARIABLE = 0x20;
		
		// <summary>
        //exception occurred looking up property, value is exception </summary>
		public const ulong FLAG_EXCEPTION = 0x40;
		
		// <summary>
        //native getter returned JS_FALSE without throwing an exception </summary>
		public const ulong FLAG_ERROR = 0x80;
		
		// <summary>
        //found via explicit lookup (property defined elsewhere.) </summary>
		public const ulong FLAG_HINTED = 0x800;
	}
}
