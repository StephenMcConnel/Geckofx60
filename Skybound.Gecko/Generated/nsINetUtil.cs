// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsINetUtil.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>
    /// nsINetUtil provides various network-related utility methods.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("ca68c485-9db3-4c12-82a6-4fab7948e2d5")]
	public interface nsINetUtil
	{
		
		/// <summary>
        /// Parse a content-type header and return the content type and
        /// charset (if any).
        ///
        /// @param aTypeHeader the header string to parse
        /// @param [out] aCharset the charset parameter specified in the
        /// header, if any.
        /// @param [out] aHadCharset whether a charset was explicitly specified.
        /// @return the MIME type specified in the header, in lower-case.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ParseContentType([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aTypeHeader, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aCharset, [MarshalAs(UnmanagedType.Bool)] ref bool aHadCharset, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase retval);
		
		/// <summary>
        /// Test whether the given URI's handler has the given protocol flags.
        ///
        /// @param aURI the URI in question
        /// @param aFlags the flags we're testing for.
        ///
        /// @return whether the protocol handler for aURI has all the flags
        /// in aFlags.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool ProtocolHasFlags([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, uint aFlag);
		
		/// <summary>
        /// Test whether the protocol handler for this URI or that for any of
        /// its inner URIs has the given protocol flags.  This will QI aURI to
        /// nsINestedURI and walk the nested URI chain.
        ///
        /// @param aURI the URI in question
        /// @param aFlags the flags we're testing for.
        ///
        /// @return whether any of the protocol handlers involved have all the flags
        /// in aFlags.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool URIChainHasFlags([MarshalAs(UnmanagedType.Interface)] nsIURI aURI, uint aFlags);
		
		/// <summary>
        /// Take aURI and produce an immutable version of it for the caller.  If aURI
        /// is immutable this will be aURI itself; otherwise this will be a clone,
        /// marked immutable if possible.  Passing null to this method is allowed; in
        /// that case it will return null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIURI ToImmutableURI([MarshalAs(UnmanagedType.Interface)] nsIURI aURI);
		
		/// <summary>
        /// Create a simple nested URI using the result of
        /// toImmutableURI on the passed-in aURI which may not be null.
        /// Note: The return URI will not have had its spec set yet.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIURI NewSimpleNestedURI([MarshalAs(UnmanagedType.Interface)] nsIURI aURI);
		
		/// <summary>
        /// escape a string with %00-style escaping
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EscapeString([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aString, uint aEscapeType, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase retval);
		
		/// <summary>
        /// %XX-Escape invalid chars in a URL segment.
        ///
        /// @param aStr the URL to be escaped
        /// @param aFlags the URL segment type flags
        ///
        /// @return the escaped string (the string itself if escaping did not happen)
        ///
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EscapeURL([MarshalAs(UnmanagedType.LPStruct)] nsACStringBase aStr, uint aFlags, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase retval);
		
		/// <summary>
        /// Expands URL escape sequences
        ///
        /// @param aStr the URL to be unescaped
        /// @param aFlags only ESCAPE_URL_ONLY_NONASCII and ESCAPE_URL_SKIP_CONTROL
        /// are recognized.  If |aFlags| is 0 all escape sequences are
        /// unescaped
        /// @return unescaped string
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void UnescapeString([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aStr, uint aFlags, [MarshalAs(UnmanagedType.LPStruct)] nsACStringBase retval);
		
		/// <summary>
        /// Extract the charset parameter location and value from a content-type
        /// header.
        ///
        /// @param aTypeHeader the header string to parse
        /// @param [out] aCharset the charset parameter specified in the
        /// header, if any.
        /// @param [out] aCharsetStart index of the start of the charset parameter
        /// (the ';' separating it from what came before) in aTypeHeader.
        /// If this function returns false, this argument will still be
        /// set, to the index of the location where a new charset should
        /// be inserted.
        /// @param [out] aCharsetEnd index of the end of the charset parameter (the
        /// ';' separating it from what comes after, or the end
        /// of the string) in aTypeHeader.  If this function returns
        /// false, this argument will still be set, to the index of the
        /// location where a new charset should be inserted.
        ///
        /// @return whether a charset parameter was found.  This can be false even in
        /// cases when parseContentType would claim to have a charset, if the type
        /// that won out does not have a charset parameter specified.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool ExtractCharsetFromContentType([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aTypeHeader, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8StringBase aCharset, ref int aCharsetStart, ref int aCharsetEnd);
	}
}
