// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsICycleCollectorListener.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Skybound.Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>
    /// Interface to pass to the cycle collector to get information about the CC
    /// graph while it's being built. The order of calls will be call to begin();
    /// then for every node in the graph a call to noteObject() and calls to
    /// noteEdge() for every edge starting at that node; then a call to
    /// beginDescriptions(); then for every black node in the CC graph a call to
    /// either describeRefcountedObject() or to describeGCedObject(); and then a
    /// call to end(). If begin() returns an error none of the other functions will
    /// be called.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("194b749a-4ceb-4dd1-928d-d30b5f14c23e")]
	public interface nsICycleCollectorListener
	{
		
		/// <summary>
        /// Interface to pass to the cycle collector to get information about the CC
        /// graph while it's being built. The order of calls will be call to begin();
        /// then for every node in the graph a call to noteObject() and calls to
        /// noteEdge() for every edge starting at that node; then a call to
        /// beginDescriptions(); then for every black node in the CC graph a call to
        /// either describeRefcountedObject() or to describeGCedObject(); and then a
        /// call to end(). If begin() returns an error none of the other functions will
        /// be called.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Begin();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteObject(uint aAddress, [MarshalAs(UnmanagedType.LPStr)] string aObjectDescription);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void NoteEdge(uint aFromAddress, uint aToAddress, [MarshalAs(UnmanagedType.LPStr)] string aEdgeName);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void BeginDescriptions();
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DescribeRefcountedObject(uint aAddress, uint aKnownEdges, uint aTotalEdges);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DescribeGCedObject(uint aAddress, [MarshalAs(UnmanagedType.Bool)] bool aMarked);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void End();
	}
}
