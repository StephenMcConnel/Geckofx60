// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIMemoryReporter.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Skybound.Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>
    /// An nsIMemoryReporter reports a single memory measurement as an object.
    /// Use this when it makes sense to gather this measurement without gathering
    /// related measurements at the same time.
    ///
    /// Note that the |amount| field may be implemented as a function, and so
    /// accessing it can trigger significant computation;  the other fields can
    /// be accessed without triggering this computation.  (Compare and contrast
    /// this with nsIMemoryMultiReporter.)
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("b2c39f65-1799-4b92-a806-ab3cf6af3cfa")]
	public interface nsIMemoryReporter
	{
		
		/// <summary>
        /// The name of the process containing this reporter.  Each reporter initially
        /// has "" in this field, indicating that it applies to the current process.
        /// (This is true even for reporters in a child process.)  When a reporter
        /// from a child process is copied into the main process, the copy has its
        /// 'process' field set appropriately.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetProcessAttribute([MarshalAs(UnmanagedType.LPStruct)] nsACString aProcess);
		
		/// <summary>
        /// The path that this memory usage should be reported under.  Paths are
        /// '/'-delimited, eg. "a/b/c".  There are two categories of paths.
        ///
        /// - Paths starting with "explicit" represent regions of memory that have
        /// been explicitly allocated with an OS-level allocation (eg.
        /// mmap/VirtualAlloc/vm_allocate) or a heap-level allocation (eg.
        /// malloc/calloc/operator new).
        ///
        /// Each reporter can be viewed as representing a node in a tree rooted at
        /// "explicit".  Not all nodes of the tree need have an associated reporter.
        /// So, for example, the reporters "explicit/a/b", "explicit/a/c",
        /// "explicit/d", "explicit/d/e", and "explicit/d/f" define this tree:
        ///
        /// explicit
        /// |--a
        /// |  |--b [*]
        /// |  \--c [*]
        /// \--d [*]
        /// |--e [*]
        /// \--f [*]
        ///
        /// Nodes marked with a [*] have a reporter.  Notice that "explicit/a" is
        /// implicitly defined.
        ///
        /// A node's children divide their parent's memory into disjoint pieces.
        /// So in the example above, |a| may not count any allocations counted by
        /// |d|, and vice versa.
        ///
        /// - All other paths represent cross-cutting values and may overlap with any
        /// other reporter.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPathAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aPath);
		
		/// <summary>
        /// The reporter kind.  See KIND_* above.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetKindAttribute();
		
		/// <summary>
        /// The units on the reporter's amount.  See UNITS_* above.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		int GetUnitsAttribute();
		
		/// <summary>
        /// The numeric value reported by this memory reporter.  -1 means "unknown",
        /// ie. something went wrong when getting the amount.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		long GetAmountAttribute();
		
		/// <summary>
        /// A human-readable description of this memory usage report.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetDescriptionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aDescription);
	}
	
	/// <summary>nsIMemoryMultiReporterCallback </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("5b15f3fa-ba15-443c-8337-7770f5f0ce5d")]
	public interface nsIMemoryMultiReporterCallback
	{
		
		/// <summary>Member Callback </summary>
		/// <param name='process'> </param>
		/// <param name='path'> </param>
		/// <param name='kind'> </param>
		/// <param name='units'> </param>
		/// <param name='amount'> </param>
		/// <param name='description'> </param>
		/// <param name='closure'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Callback([MarshalAs(UnmanagedType.LPStruct)] nsACString process, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String path, int kind, int units, long amount, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String description, [MarshalAs(UnmanagedType.Interface)] nsISupports closure);
	}
	
	/// <summary>
    /// An nsIMemoryMultiReporter reports multiple memory measurements via a
    /// callback function which is called once for each measurement.  Use this
    /// when you want to gather multiple measurements in a single operation (eg.
    /// a single traversal of a large data structure).
    ///
    /// The arguments to the callback deliberately match the fields in
    /// nsIMemoryReporter, but note that seeing any of these arguments requires
    /// calling collectReports which will trigger all relevant computation.
    /// (Compare and contrast this with nsIMemoryReporter, which allows all
    /// fields except |amount| to be accessed without triggering computation.)
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("eae277ad-b67d-4389-95f4-03fa11c09d06")]
	public interface nsIMemoryMultiReporter
	{
		
		/// <summary>
        /// An nsIMemoryMultiReporter reports multiple memory measurements via a
        /// callback function which is called once for each measurement.  Use this
        /// when you want to gather multiple measurements in a single operation (eg.
        /// a single traversal of a large data structure).
        ///
        /// The arguments to the callback deliberately match the fields in
        /// nsIMemoryReporter, but note that seeing any of these arguments requires
        /// calling collectReports which will trigger all relevant computation.
        /// (Compare and contrast this with nsIMemoryReporter, which allows all
        /// fields except |amount| to be accessed without triggering computation.)
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CollectReports([MarshalAs(UnmanagedType.Interface)] nsIMemoryMultiReporterCallback callback, [MarshalAs(UnmanagedType.Interface)] nsISupports closure);
	}
	
	/// <summary>nsIMemoryReporterManager </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("84ba9c85-3372-4423-b7ab-74708b9269a6")]
	public interface nsIMemoryReporterManager
	{
		
		/// <summary>
        /// Return an enumerator of nsIMemoryReporters that are currently registered.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISimpleEnumerator EnumerateReporters();
		
		/// <summary>
        /// Return an enumerator of nsIMemoryMultiReporters that are currently
        /// registered.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISimpleEnumerator EnumerateMultiReporters();
		
		/// <summary>
        /// Register the given nsIMemoryReporter.  After a reporter is registered,
        /// it will be available via enumerateReporters().  The Manager service
        /// will hold a strong reference to the given reporter.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RegisterReporter([MarshalAs(UnmanagedType.Interface)] nsIMemoryReporter reporter);
		
		/// <summary>
        /// Register the given nsIMemoryMultiReporter.  After a multi-reporter is
        /// registered, it will be available via enumerateMultiReporters().  The
        /// Manager service will hold a strong reference to the given
        /// multi-reporter.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RegisterMultiReporter([MarshalAs(UnmanagedType.Interface)] nsIMemoryMultiReporter reporter);
		
		/// <summary>
        /// Unregister the given memory reporter.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void UnregisterReporter([MarshalAs(UnmanagedType.Interface)] nsIMemoryReporter reporter);
		
		/// <summary>
        /// Unregister the given memory multi-reporter.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void UnregisterMultiReporter([MarshalAs(UnmanagedType.Interface)] nsIMemoryMultiReporter reporter);
		
		/// <summary>
        /// Initialize.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Init();
		
		/// <summary>
        /// Get the resident size (aka. RSS, physical memory used).  This reporter
        /// is special-cased because it's interesting, is available on all
        /// platforms, and returns a meaningful result on all common platforms.
        /// -1 means unknown.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		long GetResidentAttribute();
		
		/// <summary>
        /// Get the total size of explicit memory allocations, both at the OS-level
        /// (eg. via mmap, VirtualAlloc) and at the heap level (eg. via malloc,
        /// calloc, operator new).  (Nb: it covers all heap allocations, but will
        /// miss any OS-level ones not covered by memory reporters.)  This reporter
        /// is special-cased because it's interesting, and is moderately difficult
        /// to compute in JS.  -1 means unknown.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		long GetExplicitAttribute();
	}
}
