// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsICacheEntryDescriptor.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Skybound.Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>nsICacheEntryDescriptor </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("49c1a11d-f5d2-4f09-8262-551e64908ada")]
	public interface nsICacheEntryDescriptor : nsICacheEntryInfo
	{
		
		/// <summary>
        /// Get the client id associated with this cache entry.
        /// </summary>
		[return: MarshalAs(UnmanagedType.LPStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.String  GetClientIDAttribute();
		
		/// <summary>
        /// Get the id for the device that stores this cache entry.
        /// </summary>
		[return: MarshalAs(UnmanagedType.LPStr)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.String  GetDeviceIDAttribute();
		
		/// <summary>
        /// Get the key identifying the cache entry.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetKeyAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString  aKey);
		
		/// <summary>
        /// Get the number of times the cache entry has been opened.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.Int32  GetFetchCountAttribute();
		
		/// <summary>
        /// Get the last time the cache entry was opened (in seconds since the Epoch).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.UInt32  GetLastFetchedAttribute();
		
		/// <summary>
        /// Get the last time the cache entry was modified (in seconds since the Epoch).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.UInt32  GetLastModifiedAttribute();
		
		/// <summary>
        /// Get the expiration time of the cache entry (in seconds since the Epoch).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.UInt32  GetExpirationTimeAttribute();
		
		/// <summary>
        /// Get the cache entry data size.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new System.UInt32  GetDataSizeAttribute();
		
		/// <summary>
        /// Find out whether or not the cache entry is stream based.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool IsStreamBased();
		
		/// <summary>
        /// Set the time at which the cache entry should be considered invalid (in
        /// seconds since the Epoch).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetExpirationTime(System.UInt32  expirationTime);
		
		/// <summary>
        /// Set the cache entry data size.  This will fail if the cache entry
        /// IS stream based.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetDataSize(System.UInt32  size);
		
		/// <summary>
        /// Open blocking input stream to cache data.  This will fail if the cache
        /// entry IS NOT stream based.  Use the stream transport service to
        /// asynchronously read this stream on a background thread.  The returned
        /// stream MAY implement nsISeekableStream.
        ///
        /// @param offset
        /// read starting from this offset into the cached data.  an offset
        /// beyond the end of the stream has undefined consequences.
        ///
        /// @return blocking, unbuffered input stream.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIInputStream OpenInputStream(System.UInt32  offset);
		
		/// <summary>
        /// Open blocking output stream to cache data.  This will fail if the cache
        /// entry IS NOT stream based.  Use the stream transport service to
        /// asynchronously write to this stream on a background thread.  The returned
        /// stream MAY implement nsISeekableStream.
        ///
        /// If opening an output stream to existing cached data, the data will be
        /// truncated to the specified offset.
        ///
        /// @param offset
        /// write starting from this offset into the cached data.  an offset
        /// beyond the end of the stream has undefined consequences.
        ///
        /// @return blocking, unbuffered output stream.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIOutputStream OpenOutputStream(System.UInt32  offset);
		
		/// <summary>
        /// Get/set the cache data element.  This will fail if the cache entry
        /// IS stream based.  The cache entry holds a strong reference to this
        /// object.  The object will be released when the cache entry is destroyed.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISupports  GetCacheElementAttribute();
		
		/// <summary>
        /// Get/set the cache data element.  This will fail if the cache entry
        /// IS stream based.  The cache entry holds a strong reference to this
        /// object.  The object will be released when the cache entry is destroyed.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetCacheElementAttribute([MarshalAs(UnmanagedType.Interface)] nsISupports  aCacheElement);
		
		/// <summary>
        /// Stores the Content-Length specified in the HTTP header for this
        /// entry. Checked before we write to the cache entry, to prevent ever
        /// taking up space in the cache for an entry that we know up front
        /// is going to have to be evicted anyway. See bug 588507.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.Int64  GetPredictedDataSizeAttribute();
		
		/// <summary>
        /// Stores the Content-Length specified in the HTTP header for this
        /// entry. Checked before we write to the cache entry, to prevent ever
        /// taking up space in the cache for an entry that we know up front
        /// is going to have to be evicted anyway. See bug 588507.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetPredictedDataSizeAttribute(System.Int64  aPredictedDataSize);
		
		/// <summary>
        /// Get the access granted to this descriptor.  See nsICache.idl for the
        /// definitions of the access modes and a thorough description of their
        /// corresponding meanings.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetAccessGrantedAttribute();
		
		/// <summary>
        /// Get/set the storage policy of the cache entry.  See nsICache.idl for
        /// the definitions of the storage policies.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		System.IntPtr GetStoragePolicyAttribute();
		
		/// <summary>
        /// Get/set the storage policy of the cache entry.  See nsICache.idl for
        /// the definitions of the storage policies.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetStoragePolicyAttribute(System.IntPtr aStoragePolicy);
		
		/// <summary>
        /// Get the disk file associated with the cache entry.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIFile  GetFileAttribute();
		
		/// <summary>
        /// Get/set security info on the cache entry for this descriptor.  This fails
        /// if the storage policy is not STORE_IN_MEMORY.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISupports  GetSecurityInfoAttribute();
		
		/// <summary>
        /// Get/set security info on the cache entry for this descriptor.  This fails
        /// if the storage policy is not STORE_IN_MEMORY.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetSecurityInfoAttribute([MarshalAs(UnmanagedType.Interface)] nsISupports  aSecurityInfo);
		
		/// <summary>
        /// Doom the cache entry this descriptor references in order to slate it for
        /// removal.  Once doomed a cache entry cannot be undoomed.
        ///
        /// A descriptor with WRITE access can doom the cache entry and choose to
        /// fail pending requests.  This means that pending requests will not get
        /// a cache descriptor.  This is meant as a tool for clients that wish to
        /// instruct pending requests to skip the cache.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Doom();
		
		/// <summary>Member DoomAndFailPendingRequests </summary>
		/// <param name='status'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DoomAndFailPendingRequests(System.Int32  status);
		
		/// <summary>
        /// A writer must validate this cache object before any readers are given
        /// a descriptor to the object.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void MarkValid();
		
		/// <summary>
        /// Explicitly close the descriptor (optional).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Close();
		
		/// <summary>
        /// Methods for accessing meta data.  Meta data is a table of key/value
        /// string pairs.  The strings do not have to conform to any particular
        /// charset, but they must be null terminated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		string GetMetaDataElement([MarshalAs(UnmanagedType.LPStr)] System.String  key);
		
		/// <summary>Member SetMetaDataElement </summary>
		/// <param name='key'> </param>
		/// <param name='value'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetMetaDataElement([MarshalAs(UnmanagedType.LPStr)] System.String  key, [MarshalAs(UnmanagedType.LPStr)] System.String  value);
		
		/// <summary>
        /// Visitor will be called with key/value pair for each meta data element.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void VisitMetaData([MarshalAs(UnmanagedType.Interface)] nsICacheMetaDataVisitor  visitor);
	}
	
	/// <summary>nsICacheMetaDataVisitor </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("22f9a49c-3cf8-4c23-8006-54efb11ac562")]
	public interface nsICacheMetaDataVisitor
	{
		
		/// <summary>
        /// Called for each key/value pair in the meta data for a cache entry
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool VisitMetaDataElement([MarshalAs(UnmanagedType.LPStr)] System.String  key, [MarshalAs(UnmanagedType.LPStr)] System.String  value);
	}
}
