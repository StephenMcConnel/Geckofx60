// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIScriptSecurityManager.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Skybound.Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>nsIScriptSecurityManager </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("50eda256-4dd2-4c7c-baed-96983910af9f")]
	public interface nsIScriptSecurityManager : nsIXPCSecurityManager
	{
		
		/// <summary>
        /// For each of these hooks returning NS_OK means 'let the action continue'.
        /// Returning an error code means 'veto the action'. XPConnect will return
        /// JS_FALSE to the js engine if the action is vetoed. The implementor of this
        /// interface is responsible for setting a JS exception into the JSContext
        /// if that is appropriate.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void CanCreateWrapper(System.IntPtr aJSContext, ref System.Guid aIID, [MarshalAs(UnmanagedType.Interface)] nsISupports aObj, [MarshalAs(UnmanagedType.Interface)] nsIClassInfo aClassInfo, ref System.IntPtr aPolicy);
		
		/// <summary>Member CanCreateInstance </summary>
		/// <param name='aJSContext'> </param>
		/// <param name='aCID'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void CanCreateInstance(System.IntPtr aJSContext, ref System.Guid aCID);
		
		/// <summary>Member CanGetService </summary>
		/// <param name='aJSContext'> </param>
		/// <param name='aCID'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void CanGetService(System.IntPtr aJSContext, ref System.Guid aCID);
		
		/// <summary>
        /// Used for aAction below
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void CanAccess(uint aAction, System.IntPtr aCallContext, System.IntPtr aJSContext, System.IntPtr aJSObject, [MarshalAs(UnmanagedType.Interface)] nsISupports aObj, [MarshalAs(UnmanagedType.Interface)] nsIClassInfo aClassInfo, System.IntPtr aName, ref System.IntPtr aPolicy);
		
		/// <summary>
        /// Checks whether the running script is allowed to access aProperty.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CheckPropertyAccess(System.IntPtr aJSContext, System.IntPtr aJSObject, [MarshalAs(UnmanagedType.LPStr)] string aClassName, System.IntPtr aProperty, uint aAction);
		
		/// <summary>
        /// Check that the script currently running in context "cx" can load "uri".
        ///
        /// Will return error code NS_ERROR_DOM_BAD_URI if the load request
        /// should be denied.
        ///
        /// @param cx the JSContext of the script causing the load
        /// @param uri the URI that is being loaded
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CheckLoadURIFromScript(System.IntPtr cx, [MarshalAs(UnmanagedType.Interface)] nsIURI uri);
		
		/// <summary>
        /// Check that content with principal aPrincipal can load "uri".
        ///
        /// Will return error code NS_ERROR_DOM_BAD_URI if the load request
        /// should be denied.
        ///
        /// @param aPrincipal the principal identifying the actor causing the load
        /// @param uri the URI that is being loaded
        /// @param flags the permission set, see above
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CheckLoadURIWithPrincipal([MarshalAs(UnmanagedType.Interface)] nsIPrincipal aPrincipal, [MarshalAs(UnmanagedType.Interface)] nsIURI uri, uint flags);
		
		/// <summary>
        /// Check that content from "from" can load "uri".
        ///
        /// Will return error code NS_ERROR_DOM_BAD_URI if the load request
        /// should be denied.
        ///
        /// @param from the URI causing the load
        /// @param uri the URI that is being loaded
        /// @param flags the permission set, see above
        ///
        /// @deprecated Use checkLoadURIWithPrincipal instead of this function.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CheckLoadURI([MarshalAs(UnmanagedType.Interface)] nsIURI from, [MarshalAs(UnmanagedType.Interface)] nsIURI uri, uint flags);
		
		/// <summary>
        /// Similar to checkLoadURIWithPrincipal but there are two differences:
        ///
        /// 1) The URI is a string, not a URI object.
        /// 2) This function assumes that the URI may still be subject to fixup (and
        /// hence will check whether fixed-up versions of the URI are allowed to
        /// load as well); if any of the versions of this URI is not allowed, this
        /// function will return error code NS_ERROR_DOM_BAD_URI.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CheckLoadURIStrWithPrincipal([MarshalAs(UnmanagedType.Interface)] nsIPrincipal aPrincipal, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String uri, uint flags);
		
		/// <summary>
        /// Same as CheckLoadURI but takes string arguments for ease of use
        /// by scripts
        ///
        /// @deprecated Use checkLoadURIStrWithPrincipal instead of this function.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CheckLoadURIStr([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String from, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String uri, uint flags);
		
		/// <summary>
        /// Check that the function 'funObj' is allowed to run on 'targetObj'
        ///
        /// Will return error code NS_ERROR_DOM_SECURITY_ERR if the function
        /// should not run
        ///
        /// @param cx The current active JavaScript context.
        /// @param funObj The function trying to run..
        /// @param targetObj The object the function will run on.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CheckFunctionAccess(System.IntPtr cx, System.IntPtr funObj, System.IntPtr targetObj);
		
		/// <summary>
        /// Return true if content from the given principal is allowed to
        /// execute scripts.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool CanExecuteScripts(System.IntPtr cx, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal);
		
		/// <summary>
        /// Return the principal of the innermost frame of the currently
        /// executing script. Will return null if there is no script
        /// currently executing.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIPrincipal GetSubjectPrincipal();
		
		/// <summary>
        /// Return the all-powerful system principal.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIPrincipal GetSystemPrincipal();
		
		/// <summary>
        /// Return a principal with the specified certificate fingerprint, subject
        /// name (the full name or concatenated set of names of the entity
        /// represented by the certificate), pretty name, certificate, and
        /// codebase URI.  The certificate fingerprint and subject name MUST be
        /// nonempty; otherwise an error will be thrown.  Similarly, aCert must
        /// not be null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIPrincipal GetCertificatePrincipal([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aCertFingerprint, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aSubjectName, [MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aPrettyName, [MarshalAs(UnmanagedType.Interface)] nsISupports aCert, [MarshalAs(UnmanagedType.Interface)] nsIURI aURI);
		
		/// <summary>
        /// Return a principal that has the same origin as aURI.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIPrincipal GetCodebasePrincipal([MarshalAs(UnmanagedType.Interface)] nsIURI aURI);
		
		/// <summary>
        /// Request that 'capability' can be enabled by scripts or applets
        /// running with 'principal'. Will prompt user if
        /// necessary. Returns nsIPrincipal::ENABLE_GRANTED or
        /// nsIPrincipal::ENABLE_DENIED based on user's choice.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		short RequestCapability([MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal, [MarshalAs(UnmanagedType.LPStr)] string capability);
		
		/// <summary>
        /// Return true if the currently executing script has 'capability' enabled.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsCapabilityEnabled([MarshalAs(UnmanagedType.LPStr)] string capability);
		
		/// <summary>
        /// Enable 'capability' in the innermost frame of the currently executing
        /// script.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void EnableCapability([MarshalAs(UnmanagedType.LPStr)] string capability);
		
		/// <summary>
        /// Remove 'capability' from the innermost frame of the currently
        /// executing script. Any setting of 'capability' from enclosing
        /// frames thus comes into effect.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void RevertCapability([MarshalAs(UnmanagedType.LPStr)] string capability);
		
		/// <summary>
        /// Disable 'capability' in the innermost frame of the currently executing
        /// script.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void DisableCapability([MarshalAs(UnmanagedType.LPStr)] string capability);
		
		/// <summary>
        /// cert we're enabling for...
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetCanEnableCapability([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String certificateFingerprint, [MarshalAs(UnmanagedType.LPStr)] string capability, short canEnable);
		
		/// <summary>
        /// Return the principal of the specified object in the specified context.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIPrincipal GetObjectPrincipal(System.IntPtr cx, System.IntPtr obj);
		
		/// <summary>
        /// Returns true if the principal of the currently running script is the
        /// system principal, false otherwise.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool SubjectPrincipalIsSystem();
		
		/// <summary>
        /// Returns OK if aJSContext and target have the same "origin"
        /// (scheme, host, and port).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CheckSameOrigin(System.IntPtr aJSContext, [MarshalAs(UnmanagedType.Interface)] nsIURI aTargetURI);
		
		/// <summary>
        /// Returns OK if aSourceURI and target have the same "origin"
        /// (scheme, host, and port).
        /// ReportError flag suppresses error reports for functions that
        /// don't need reporting.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void CheckSameOriginURI([MarshalAs(UnmanagedType.Interface)] nsIURI aSourceURI, [MarshalAs(UnmanagedType.Interface)] nsIURI aTargetURI, [MarshalAs(UnmanagedType.Bool)] bool reportError);
		
		/// <summary>
        /// Returns the principal of the global object of the given context, or null
        /// if no global or no principal.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIPrincipal GetPrincipalFromContext(System.IntPtr cx);
		
		/// <summary>
        /// Get the principal for the given channel.  This will typically be the
        /// channel owner if there is one, and the codebase principal for the
        /// channel's URI otherwise.  aChannel must not be null.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIPrincipal GetChannelPrincipal([MarshalAs(UnmanagedType.Interface)] nsIChannel aChannel);
		
		/// <summary>
        /// Check whether a given principal is a system principal.  This allows us
        /// to avoid handing back the system principal to script while allowing
        /// script to check whether a given principal is system.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		bool IsSystemPrincipal([MarshalAs(UnmanagedType.Interface)] nsIPrincipal aPrincipal);
		
		/// <summary>
        /// Same as getSubjectPrincipal(), only faster. cx must *never* be
        /// passed null, and it must be the context on the top of the
        /// context stack. Does *not* reference count the returned
        /// principal.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIPrincipal GetCxSubjectPrincipal(System.IntPtr cx);
		
		/// <summary>Member GetCxSubjectPrincipalAndFrame </summary>
		/// <param name='cx'> </param>
		/// <param name='fp'> </param>
		/// <returns>A nsIPrincipal</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIPrincipal GetCxSubjectPrincipalAndFrame(System.IntPtr cx, ref System.IntPtr fp);
		
		/// <summary>
        /// If no scripted code is running "above" (or called from) fp, then
        /// instead of looking at cx->globalObject, we will return |principal|.
        /// This function only affects |cx|. If someone pushes another context onto
        /// the context stack, then it supersedes this call.
        /// NOTE: If |fp| is non-null popContextPrincipal must be called before fp
        /// has finished executing.
        ///
        /// @param cx The context to clamp.
        /// @param fp The frame pointer to clamp at. May be 'null'.
        /// @param principal The principal to clamp to.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PushContextPrincipal(System.IntPtr cx, System.IntPtr fp, [MarshalAs(UnmanagedType.Interface)] nsIPrincipal principal);
		
		/// <summary>
        /// Removes a clamp set by pushContextPrincipal from cx. This must be
        /// called in a stack-like fashion (e.g., given two contexts |a| and |b|,
        /// it is not legal to do: push(a) push(b) pop(a)).
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PopContextPrincipal(System.IntPtr cx);
	}
}
