// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsITimelineService.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Skybound.Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>
    /// nsITimelineService is used to construct a timeline of program
    /// execution.  The timeline is output to a file, either stderr or the
    /// value of the environment variable NS_TIMELINE_LOG_FILE.  On the
    /// Mac, the timeline is output to the file named "timeline.txt".  The
    /// reason it's different on the Mac is that the Mac environment
    /// initialization code happens after timeline initialization code.
    ///
    /// If NS_TIMELINE_INIT_TIME is set in the environment, that will be
    /// used as the time of startup; otherwise the current time when mark()
    /// is first called will be used.
    ///
    /// mark() is used to put marks on the timeline.
    ///
    /// indent() and outdent() are used to format the timeline a bit to
    /// show nesting.  This doesn't produce perfect results in the face of
    /// asychrony and multiple threads.
    ///
    /// enter() and leave() are convenience functions that add marks to the
    /// timeline and do indentation.
    ///
    /// startTimer() and stopTimer() control named stop watches.  If
    /// startTimer() is called more than once, an equal number of
    /// stopTimer() calls are needed to actually stop the timer.  This
    /// makes these timers slightly useful in a threaded environment.
    ///
    /// markTimer() puts a mark on the timeline containing the total for
    /// the named timer.
    ///
    /// Don't use nsITimelineService in C++ code; use the NS_TIMELINE
    /// macros instead.  nsITimelineService exists so that JavaScript code
    /// can mark the timeline.
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("93276790-3daf-11d5-b67d-000064657374")]
	public interface nsITimelineService
	{
		
		/// <summary>
        /// mark()
        /// Print "<elapsed time>: <text>\n" in the timeline log file.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Mark([MarshalAs(UnmanagedType.LPStr)] System.String  text);
		
		/// <summary>
        /// causes subsequent marks to be indented for a more readable
        /// report.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Indent();
		
		/// <summary>
        /// Causes subsequent marks to be outdented.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Outdent();
		
		/// <summary>
        /// enter/leave bracket code with "<text>..." and "...<text>" as
        /// well as indentation.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Enter([MarshalAs(UnmanagedType.LPStr)] System.String  text);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Leave([MarshalAs(UnmanagedType.LPStr)] System.String  text);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StartTimer([MarshalAs(UnmanagedType.LPStr)] System.String  timerName);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void StopTimer([MarshalAs(UnmanagedType.LPStr)] System.String  timerName);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void MarkTimer([MarshalAs(UnmanagedType.LPStr)] System.String  timerName);
		
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ResetTimer([MarshalAs(UnmanagedType.LPStr)] System.String  timerName);
		
		/// <summary>
        /// Mark a timer, plus an additional comment
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void MarkTimerWithComment([MarshalAs(UnmanagedType.LPStr)] System.String  timerName, [MarshalAs(UnmanagedType.LPStr)] System.String  comment);
	}
}
