// --------------------------------------------------------------------------------------------
// Version: MPL 1.1/GPL 2.0/LGPL 2.1
// 
// The contents of this file are subject to the Mozilla Public License Version
// 1.1 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
// http://www.mozilla.org/MPL/
// 
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
// for the specific language governing rights and limitations under the
// License.
// 
// <remarks>
// Generated by IDLImporter from file nsIDOMWorkers.idl
// 
// You should use these interfaces when you access the COM objects defined in the mentioned
// IDL/IDH file.
// </remarks>
// --------------------------------------------------------------------------------------------
namespace Skybound.Gecko
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.InteropServices.ComTypes;
	using System.Runtime.CompilerServices;
	using System.Windows.Forms;
	
	
	/// <summary>
    /// From http://www.whatwg.org/specs/web-workers/current-work
    /// </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("ab3725b8-3fca-40cc-a42c-92fb154ef01d")]
	public interface nsIWorkerMessagePort
	{
		
		/// <summary>
        ///in JSObject aMessage </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PostMessage();
	}
	
	/// <summary>nsIWorkerMessageEvent </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("508f2d49-e9a0-4fe8-bd33-321820173b4a")]
	public interface nsIWorkerMessageEvent : nsIDOMEvent
	{
		
		/// <summary>
        /// The name of the event (case-insensitive). The name must be an XML
        /// name.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetTypeAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aType);
		
		/// <summary>
        /// Used to indicate the EventTarget to which the event was originally
        /// dispatched.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDOMEventTarget GetTargetAttribute();
		
		/// <summary>
        /// Used to indicate the EventTarget whose EventListeners are currently
        /// being processed. This is particularly useful during capturing and
        /// bubbling.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDOMEventTarget GetCurrentTargetAttribute();
		
		/// <summary>
        /// Used to indicate which phase of event flow is currently being
        /// evaluated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new ushort GetEventPhaseAttribute();
		
		/// <summary>
        /// Used to indicate whether or not an event is a bubbling event. If the
        /// event can bubble the value is true, else the value is false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetBubblesAttribute();
		
		/// <summary>
        /// Used to indicate whether or not an event can have its default action
        /// prevented. If the default action can be prevented the value is true,
        /// else the value is false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetCancelableAttribute();
		
		/// <summary>
        /// Used to specify the time (in milliseconds relative to the epoch) at
        /// which the event was created. Due to the fact that some systems may
        /// not provide this information the value of timeStamp may be not
        /// available for all events. When not available, a value of 0 will be
        /// returned. Examples of epoch time are the time of the system start or
        /// 0:0:0 UTC 1st January 1970.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new long GetTimeStampAttribute();
		
		/// <summary>
        /// The stopPropagation method is used prevent further propagation of an
        /// event during event flow. If this method is called by any
        /// EventListener the event will cease propagating through the tree. The
        /// event will complete dispatch to all listeners on the current
        /// EventTarget before event flow stops. This method may be used during
        /// any stage of event flow.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void StopPropagation();
		
		/// <summary>
        /// If an event is cancelable, the preventDefault method is used to
        /// signify that the event is to be canceled, meaning any default action
        /// normally taken by the implementation as a result of the event will
        /// not occur. If, during any stage of event flow, the preventDefault
        /// method is called the event is canceled. Any default action associated
        /// with the event will not occur. Calling this method for a
        /// non-cancelable event has no effect. Once preventDefault has been
        /// called it will remain in effect throughout the remainder of the
        /// event's propagation. This method may be used during any stage of
        /// event flow.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void PreventDefault();
		
		/// <summary>
        /// The initEvent method is used to initialize the value of an Event
        /// created through the DocumentEvent interface. This method may only be
        /// called before the Event has been dispatched via the dispatchEvent
        /// method, though it may be called multiple times during that phase if
        /// necessary. If called multiple times the final invocation takes
        /// precedence. If called from a subclass of Event interface only the
        /// values specified in the initEvent method are modified, all other
        /// attributes are left unchanged.
        ///
        /// @param   eventTypeArg Specifies the event type. This type may be
        /// any event type currently defined in this
        /// specification or a new event type.. The string
        /// must be an XML name.
        /// Any new event type must not begin with any
        /// upper, lower, or mixed case version of the
        /// string "DOM". This prefix is reserved for
        /// future DOM event sets. It is also strongly
        /// recommended that third parties adding their
        /// own events use their own prefix to avoid
        /// confusion and lessen the probability of
        /// conflicts with other new events.
        /// @param   canBubbleArg Specifies whether or not the event can bubble.
        /// @param   cancelableArg Specifies whether or not the event's default
        /// action can be prevented.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void InitEvent([MarshalAs(UnmanagedType.LPStruct)] nsAString eventTypeArg, [MarshalAs(UnmanagedType.Bool)] bool canBubbleArg, [MarshalAs(UnmanagedType.Bool)] bool cancelableArg);
		
		/// <summary>
        /// Used to indicate whether preventDefault() has been called for this event.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetDefaultPreventedAttribute();
		
		/// <summary>Member GetDataAttribute </summary>
		/// <param name='aData'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetDataAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aData);
		
		/// <summary>Member GetOriginAttribute </summary>
		/// <param name='aOrigin'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetOriginAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aOrigin);
		
		/// <summary>Member GetSourceAttribute </summary>
		/// <returns>A nsISupports</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsISupports GetSourceAttribute();
		
		/// <summary>Member InitMessageEvent </summary>
		/// <param name='aTypeArg'> </param>
		/// <param name='aCanBubbleArg'> </param>
		/// <param name='aCancelableArg'> </param>
		/// <param name='aDataArg'> </param>
		/// <param name='aOriginArg'> </param>
		/// <param name='aSourceArg'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InitMessageEvent([MarshalAs(UnmanagedType.LPStruct)] nsAString aTypeArg, [MarshalAs(UnmanagedType.Bool)] bool aCanBubbleArg, [MarshalAs(UnmanagedType.Bool)] bool aCancelableArg, [MarshalAs(UnmanagedType.LPStruct)] nsAString aDataArg, [MarshalAs(UnmanagedType.LPStruct)] nsAString aOriginArg, [MarshalAs(UnmanagedType.Interface)] nsISupports aSourceArg);
	}
	
	/// <summary>nsIWorkerErrorEvent </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("73d82c1d-05de-49c9-a23b-7121ff09a67a")]
	public interface nsIWorkerErrorEvent : nsIDOMEvent
	{
		
		/// <summary>
        /// The name of the event (case-insensitive). The name must be an XML
        /// name.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void GetTypeAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aType);
		
		/// <summary>
        /// Used to indicate the EventTarget to which the event was originally
        /// dispatched.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDOMEventTarget GetTargetAttribute();
		
		/// <summary>
        /// Used to indicate the EventTarget whose EventListeners are currently
        /// being processed. This is particularly useful during capturing and
        /// bubbling.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDOMEventTarget GetCurrentTargetAttribute();
		
		/// <summary>
        /// Used to indicate which phase of event flow is currently being
        /// evaluated.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new ushort GetEventPhaseAttribute();
		
		/// <summary>
        /// Used to indicate whether or not an event is a bubbling event. If the
        /// event can bubble the value is true, else the value is false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetBubblesAttribute();
		
		/// <summary>
        /// Used to indicate whether or not an event can have its default action
        /// prevented. If the default action can be prevented the value is true,
        /// else the value is false.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetCancelableAttribute();
		
		/// <summary>
        /// Used to specify the time (in milliseconds relative to the epoch) at
        /// which the event was created. Due to the fact that some systems may
        /// not provide this information the value of timeStamp may be not
        /// available for all events. When not available, a value of 0 will be
        /// returned. Examples of epoch time are the time of the system start or
        /// 0:0:0 UTC 1st January 1970.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new long GetTimeStampAttribute();
		
		/// <summary>
        /// The stopPropagation method is used prevent further propagation of an
        /// event during event flow. If this method is called by any
        /// EventListener the event will cease propagating through the tree. The
        /// event will complete dispatch to all listeners on the current
        /// EventTarget before event flow stops. This method may be used during
        /// any stage of event flow.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void StopPropagation();
		
		/// <summary>
        /// If an event is cancelable, the preventDefault method is used to
        /// signify that the event is to be canceled, meaning any default action
        /// normally taken by the implementation as a result of the event will
        /// not occur. If, during any stage of event flow, the preventDefault
        /// method is called the event is canceled. Any default action associated
        /// with the event will not occur. Calling this method for a
        /// non-cancelable event has no effect. Once preventDefault has been
        /// called it will remain in effect throughout the remainder of the
        /// event's propagation. This method may be used during any stage of
        /// event flow.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void PreventDefault();
		
		/// <summary>
        /// The initEvent method is used to initialize the value of an Event
        /// created through the DocumentEvent interface. This method may only be
        /// called before the Event has been dispatched via the dispatchEvent
        /// method, though it may be called multiple times during that phase if
        /// necessary. If called multiple times the final invocation takes
        /// precedence. If called from a subclass of Event interface only the
        /// values specified in the initEvent method are modified, all other
        /// attributes are left unchanged.
        ///
        /// @param   eventTypeArg Specifies the event type. This type may be
        /// any event type currently defined in this
        /// specification or a new event type.. The string
        /// must be an XML name.
        /// Any new event type must not begin with any
        /// upper, lower, or mixed case version of the
        /// string "DOM". This prefix is reserved for
        /// future DOM event sets. It is also strongly
        /// recommended that third parties adding their
        /// own events use their own prefix to avoid
        /// confusion and lessen the probability of
        /// conflicts with other new events.
        /// @param   canBubbleArg Specifies whether or not the event can bubble.
        /// @param   cancelableArg Specifies whether or not the event's default
        /// action can be prevented.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void InitEvent([MarshalAs(UnmanagedType.LPStruct)] nsAString eventTypeArg, [MarshalAs(UnmanagedType.Bool)] bool canBubbleArg, [MarshalAs(UnmanagedType.Bool)] bool cancelableArg);
		
		/// <summary>
        /// Used to indicate whether preventDefault() has been called for this event.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool GetDefaultPreventedAttribute();
		
		/// <summary>Member GetMessageAttribute </summary>
		/// <param name='aMessage'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetMessageAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aMessage);
		
		/// <summary>Member GetFilenameAttribute </summary>
		/// <param name='aFilename'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetFilenameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aFilename);
		
		/// <summary>Member GetLinenoAttribute </summary>
		/// <returns>A System.UInt32</returns>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		uint GetLinenoAttribute();
		
		/// <summary>Member InitErrorEvent </summary>
		/// <param name='aTypeArg'> </param>
		/// <param name='aCanBubbleArg'> </param>
		/// <param name='aCancelableArg'> </param>
		/// <param name='aMessageArg'> </param>
		/// <param name='aFilenameArg'> </param>
		/// <param name='aLinenoArg'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void InitErrorEvent([MarshalAs(UnmanagedType.LPStruct)] nsAString aTypeArg, [MarshalAs(UnmanagedType.Bool)] bool aCanBubbleArg, [MarshalAs(UnmanagedType.Bool)] bool aCancelableArg, [MarshalAs(UnmanagedType.LPStruct)] nsAString aMessageArg, [MarshalAs(UnmanagedType.LPStruct)] nsAString aFilenameArg, uint aLinenoArg);
	}
	
	/// <summary>nsIWorkerLocation </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("17a005c3-4f2f-4bb6-b169-c181fa6873de")]
	public interface nsIWorkerLocation
	{
		
		/// <summary>Member GetHrefAttribute </summary>
		/// <param name='aHref'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetHrefAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aHref);
		
		/// <summary>Member GetProtocolAttribute </summary>
		/// <param name='aProtocol'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetProtocolAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aProtocol);
		
		/// <summary>Member GetHostAttribute </summary>
		/// <param name='aHost'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetHostAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aHost);
		
		/// <summary>Member GetHostnameAttribute </summary>
		/// <param name='aHostname'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetHostnameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aHostname);
		
		/// <summary>Member GetPortAttribute </summary>
		/// <param name='aPort'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPortAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aPort);
		
		/// <summary>Member GetPathnameAttribute </summary>
		/// <param name='aPathname'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPathnameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aPathname);
		
		/// <summary>Member GetSearchAttribute </summary>
		/// <param name='aSearch'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetSearchAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aSearch);
		
		/// <summary>Member GetHashAttribute </summary>
		/// <param name='aHash'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetHashAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String aHash);
		
		/// <summary>Member ToString </summary>
		/// <param name='retval'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void ToString([MarshalAs(UnmanagedType.LPStruct)] nsAUTF8String retval);
	}
	
	/// <summary>nsIWorkerNavigator </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("74fb665a-e477-4ce2-b3c6-c58b1b28b6c3")]
	public interface nsIWorkerNavigator
	{
		
		/// <summary>Member GetAppNameAttribute </summary>
		/// <param name='aAppName'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetAppNameAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aAppName);
		
		/// <summary>Member GetAppVersionAttribute </summary>
		/// <param name='aAppVersion'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetAppVersionAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aAppVersion);
		
		/// <summary>Member GetPlatformAttribute </summary>
		/// <param name='aPlatform'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetPlatformAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aPlatform);
		
		/// <summary>Member GetUserAgentAttribute </summary>
		/// <param name='aUserAgent'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void GetUserAgentAttribute([MarshalAs(UnmanagedType.LPStruct)] nsAString aUserAgent);
	}
	
	/// <summary>nsIWorkerGlobalScope </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("c111e7d3-8044-4458-aa7b-637696ffb841")]
	public interface nsIWorkerGlobalScope
	{
		
		/// <summary>Member GetSelfAttribute </summary>
		/// <returns>A nsIWorkerGlobalScope</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIWorkerGlobalScope GetSelfAttribute();
		
		/// <summary>Member GetNavigatorAttribute </summary>
		/// <returns>A nsIWorkerNavigator</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIWorkerNavigator GetNavigatorAttribute();
		
		/// <summary>Member GetLocationAttribute </summary>
		/// <returns>A nsIWorkerLocation</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIWorkerLocation GetLocationAttribute();
		
		/// <summary>Member GetOnerrorAttribute </summary>
		/// <returns>A nsIDOMEventListener</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMEventListener GetOnerrorAttribute();
		
		/// <summary>Member SetOnerrorAttribute </summary>
		/// <param name='aOnerror'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetOnerrorAttribute([MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener aOnerror);
	}
	
	/// <summary>nsIWorkerScope </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("5c55ea4b-e4ac-4ceb-bfeb-46bd5e521b8a")]
	public interface nsIWorkerScope : nsIWorkerGlobalScope
	{
		
		/// <summary>Member GetSelfAttribute </summary>
		/// <returns>A nsIWorkerGlobalScope</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIWorkerGlobalScope GetSelfAttribute();
		
		/// <summary>Member GetNavigatorAttribute </summary>
		/// <returns>A nsIWorkerNavigator</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIWorkerNavigator GetNavigatorAttribute();
		
		/// <summary>Member GetLocationAttribute </summary>
		/// <returns>A nsIWorkerLocation</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIWorkerLocation GetLocationAttribute();
		
		/// <summary>Member GetOnerrorAttribute </summary>
		/// <returns>A nsIDOMEventListener</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDOMEventListener GetOnerrorAttribute();
		
		/// <summary>Member SetOnerrorAttribute </summary>
		/// <param name='aOnerror'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetOnerrorAttribute([MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener aOnerror);
		
		/// <summary>
        ///in JSObject aMessage </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PostMessage();
		
		/// <summary>Member Close </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Close();
		
		/// <summary>Member GetOnmessageAttribute </summary>
		/// <returns>A nsIDOMEventListener</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMEventListener GetOnmessageAttribute();
		
		/// <summary>Member SetOnmessageAttribute </summary>
		/// <param name='aOnmessage'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetOnmessageAttribute([MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener aOnmessage);
		
		/// <summary>Member GetOncloseAttribute </summary>
		/// <returns>A nsIDOMEventListener</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMEventListener GetOncloseAttribute();
		
		/// <summary>Member SetOncloseAttribute </summary>
		/// <param name='aOnclose'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetOncloseAttribute([MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener aOnclose);
	}
	
	/// <summary>nsIAbstractWorker </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("b90b7561-b5e2-4545-84b0-280dbaaa94ea")]
	public interface nsIAbstractWorker : nsIDOMEventTarget
	{
		
		/// <summary>
        /// This method allows the registration of event listeners on the event target.
        /// If an EventListener is added to an EventTarget while it is processing an
        /// event, it will not be triggered by the current actions but may be
        /// triggered during a later stage of event flow, such as the bubbling phase.
        ///
        /// If multiple identical EventListeners are registered on the same
        /// EventTarget with the same parameters the duplicate instances are
        /// discarded. They do not cause the EventListener to be called twice
        /// and since they are discarded they do not need to be removed with the
        /// removeEventListener method.
        ///
        /// @param   type The event type for which the user is registering
        /// @param   listener The listener parameter takes an interface
        /// implemented by the user which contains the methods
        /// to be called when the event occurs.
        /// @param   useCapture If true, useCapture indicates that the user
        /// wishes to initiate capture. After initiating
        /// capture, all events of the specified type will be
        /// dispatched to the registered EventListener before
        /// being dispatched to any EventTargets beneath them
        /// in the tree. Events which are bubbling upward
        /// through the tree will not trigger an
        /// EventListener designated to use capture.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddEventListener([MarshalAs(UnmanagedType.LPStruct)] nsAString type, [MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener listener, [MarshalAs(UnmanagedType.Bool)] bool useCapture);
		
		/// <summary>
        /// This method allows the removal of event listeners from the event
        /// target. If an EventListener is removed from an EventTarget while it
        /// is processing an event, it will not be triggered by the current actions.
        /// EventListeners can never be invoked after being removed.
        /// Calling removeEventListener with arguments which do not identify any
        /// currently registered EventListener on the EventTarget has no effect.
        ///
        /// @param   type Specifies the event type of the EventListener being
        /// removed.
        /// @param   listener The EventListener parameter indicates the
        /// EventListener to be removed.
        /// @param   useCapture Specifies whether the EventListener being
        /// removed was registered as a capturing listener or
        /// not. If a listener was registered twice, one with
        /// capture and one without, each must be removed
        /// separately. Removal of a capturing listener does
        /// not affect a non-capturing version of the same
        /// listener, and vice versa.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveEventListener([MarshalAs(UnmanagedType.LPStruct)] nsAString type, [MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener listener, [MarshalAs(UnmanagedType.Bool)] bool useCapture);
		
		/// <summary>
        /// This method allows the dispatch of events into the implementations
        /// event model. Events dispatched in this manner will have the same
        /// capturing and bubbling behavior as events dispatched directly by the
        /// implementation. The target of the event is the EventTarget on which
        /// dispatchEvent is called.
        ///
        /// @param   evt Specifies the event type, behavior, and contextual
        /// information to be used in processing the event.
        /// @return  Indicates whether any of the listeners which handled the
        /// event called preventDefault. If preventDefault was called
        /// the value is false, else the value is true.
        /// @throws  UNSPECIFIED_EVENT_TYPE_ERR: Raised if the Event's type was
        /// not specified by initializing the event before
        /// dispatchEvent was called. Specification of the Event's
        /// type as null or an empty string will also trigger this
        /// exception.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool DispatchEvent([MarshalAs(UnmanagedType.Interface)] nsIDOMEvent evt);
		
		/// <summary>Member GetOnerrorAttribute </summary>
		/// <returns>A nsIDOMEventListener</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMEventListener GetOnerrorAttribute();
		
		/// <summary>Member SetOnerrorAttribute </summary>
		/// <param name='aOnerror'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetOnerrorAttribute([MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener aOnerror);
	}
	
	/// <summary>nsIWorker </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("daf945c3-8d29-4724-8939-dd383f7d27a7")]
	public interface nsIWorker : nsIAbstractWorker
	{
		
		/// <summary>
        /// This method allows the registration of event listeners on the event target.
        /// If an EventListener is added to an EventTarget while it is processing an
        /// event, it will not be triggered by the current actions but may be
        /// triggered during a later stage of event flow, such as the bubbling phase.
        ///
        /// If multiple identical EventListeners are registered on the same
        /// EventTarget with the same parameters the duplicate instances are
        /// discarded. They do not cause the EventListener to be called twice
        /// and since they are discarded they do not need to be removed with the
        /// removeEventListener method.
        ///
        /// @param   type The event type for which the user is registering
        /// @param   listener The listener parameter takes an interface
        /// implemented by the user which contains the methods
        /// to be called when the event occurs.
        /// @param   useCapture If true, useCapture indicates that the user
        /// wishes to initiate capture. After initiating
        /// capture, all events of the specified type will be
        /// dispatched to the registered EventListener before
        /// being dispatched to any EventTargets beneath them
        /// in the tree. Events which are bubbling upward
        /// through the tree will not trigger an
        /// EventListener designated to use capture.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void AddEventListener([MarshalAs(UnmanagedType.LPStruct)] nsAString type, [MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener listener, [MarshalAs(UnmanagedType.Bool)] bool useCapture);
		
		/// <summary>
        /// This method allows the removal of event listeners from the event
        /// target. If an EventListener is removed from an EventTarget while it
        /// is processing an event, it will not be triggered by the current actions.
        /// EventListeners can never be invoked after being removed.
        /// Calling removeEventListener with arguments which do not identify any
        /// currently registered EventListener on the EventTarget has no effect.
        ///
        /// @param   type Specifies the event type of the EventListener being
        /// removed.
        /// @param   listener The EventListener parameter indicates the
        /// EventListener to be removed.
        /// @param   useCapture Specifies whether the EventListener being
        /// removed was registered as a capturing listener or
        /// not. If a listener was registered twice, one with
        /// capture and one without, each must be removed
        /// separately. Removal of a capturing listener does
        /// not affect a non-capturing version of the same
        /// listener, and vice versa.
        /// </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void RemoveEventListener([MarshalAs(UnmanagedType.LPStruct)] nsAString type, [MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener listener, [MarshalAs(UnmanagedType.Bool)] bool useCapture);
		
		/// <summary>
        /// This method allows the dispatch of events into the implementations
        /// event model. Events dispatched in this manner will have the same
        /// capturing and bubbling behavior as events dispatched directly by the
        /// implementation. The target of the event is the EventTarget on which
        /// dispatchEvent is called.
        ///
        /// @param   evt Specifies the event type, behavior, and contextual
        /// information to be used in processing the event.
        /// @return  Indicates whether any of the listeners which handled the
        /// event called preventDefault. If preventDefault was called
        /// the value is false, else the value is true.
        /// @throws  UNSPECIFIED_EVENT_TYPE_ERR: Raised if the Event's type was
        /// not specified by initializing the event before
        /// dispatchEvent was called. Specification of the Event's
        /// type as null or an empty string will also trigger this
        /// exception.
        /// </summary>
		[return: MarshalAs(UnmanagedType.Bool)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new bool DispatchEvent([MarshalAs(UnmanagedType.Interface)] nsIDOMEvent evt);
		
		/// <summary>Member GetOnerrorAttribute </summary>
		/// <returns>A nsIDOMEventListener</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new nsIDOMEventListener GetOnerrorAttribute();
		
		/// <summary>Member SetOnerrorAttribute </summary>
		/// <param name='aOnerror'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		new void SetOnerrorAttribute([MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener aOnerror);
		
		/// <summary>
        ///in JSObject aMessage </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void PostMessage();
		
		/// <summary>Member GetOnmessageAttribute </summary>
		/// <returns>A nsIDOMEventListener</returns>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIDOMEventListener GetOnmessageAttribute();
		
		/// <summary>Member SetOnmessageAttribute </summary>
		/// <param name='aOnmessage'> </param>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void SetOnmessageAttribute([MarshalAs(UnmanagedType.Interface)] nsIDOMEventListener aOnmessage);
		
		/// <summary>Member Terminate </summary>
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		void Terminate();
	}
	
	/// <summary>nsIWorkerFactory </summary>
	[ComImport()]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	[Guid("cfc4bb32-ca83-4d58-9b6f-66f8054a333a")]
	public interface nsIWorkerFactory
	{
		
		/// <summary>
        ///in DOMString aScriptURL </summary>
		[return: MarshalAs(UnmanagedType.Interface)]
		[MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime)]
		nsIWorker NewChromeWorker();
	}
}
